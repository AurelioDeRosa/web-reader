{"version":3,"sources":["node_modules/browser-pack/_prelude.js","lang/en-GB.json","node_modules/damerau-levenshtein/damerau-levenshtein.js","src/commands.js","src/dom/document.js","src/dom/dom.js","src/dom/headers.js","src/dom/links.js","src/dom/main.js","src/helpers/event-emitter.js","src/helpers/string-comparers/damerau-levenshtein-comparer.js","src/helpers/string-comparers/string-comparer.js","src/helpers/timer.js","src/main.js","src/reader/recognizer.js","src/reader/speaker.js","src/router.js","src/webreader-error.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpGA,OAAI,cAAc,IAAlB;;;;;;;;;;;;;;;;;;;;AAoBA,YAAS,kBAAT,CAA4B,cAA5B,EAA4C,cAA5C,EAA4D;AACzD,UAAM,gBAAgB,YAAY,QAAZ,CAAqB,kBAArB,CAAwC,MAA9D;AACA,UAAI,OAAO,EAAX;;AAEA,WAAI,IAAI,IAAI,CAAZ,EAAe,IAAI,cAAc,MAAjC,EAAyC,GAAzC,EAA8C;AAC3C,aAAI,SAAS,IAAI,MAAJ,eAAsB,IAAI,CAA1B,YAAgC,IAAI,CAApC,UAAyC,cAAc,CAAd,CAAzC,eAAqE,GAArE,CAAb;;AAEA,aAAI,OAAO,IAAP,CAAY,cAAZ,CAAJ,EAAiC;AAC9B,iBAAK,KAAL,GAAa,IAAI,CAAjB;AACA;AACF;AACH;;;;AAID,UAAI,CAAC,KAAK,KAAV,EAAiB;AACd,aAAI,mBAAmB,eAAe,eAAf,CAA+B,aAA/B,EAA8C,cAA9C,EAA8D,KAArF;;AAEA,cAAK,KAAL,GAAa,qBAAqB,CAAC,CAAtB,GAA0B,CAAC,CAA3B,GAA+B,mBAAmB,CAA/D;AACF;;AAED,aAAO,IAAP;AACF;;;;;;;;;;AAUD,YAAS,iBAAT,CAA2B,cAA3B,EAA2C;AACxC,UAAI,WAAW,YAAY,QAA3B;AACA,UAAI,eAAe,IAAnB;;AAEA,WAAI,IAAI,GAAR,IAAe,QAAf,EAAyB;AACtB,aAAI,aAAa,SAAS,GAAT,EAAc,UAAd,CAAyB,IAAzB,CAA8B,GAA9B,CAAjB;AACA,aAAI,SAAS,IAAI,MAAJ,cAAsB,UAAtB,eAA4C,GAA5C,CAAb;;AAEA,aAAI,OAAO,IAAP,CAAY,cAAZ,CAAJ,EAAiC;AAC9B,2BAAe,SAAS,aAAT,CAAuB,SAAS,GAAT,EAAc,QAArC,CAAf;AACA;AACF;AACH;;AAED,aAAO,YAAP;AACF;;;;;;;;;;AAUD,YAAS,sBAAT,CAAgC,cAAhC,EAAgD,cAAhD,EAAgE;AAC7D,UAAI,eAAe,kBAAkB,cAAlB,CAAnB;;AAEA,UAAI,YAAJ,EAAkB;AACf,gBAAO;AACJ,qBAAS;AADL,UAAP;AAGF;;;AAGD,UAAI,gBAAgB,EAApB;AACA,UAAI,WAAW,YAAY,QAA3B;;;;AAIA,WAAI,IAAI,GAAR,IAAe,QAAf,EAAyB;AACtB,aAAI,aAAa,SAAS,GAAT,EAAc,UAA/B;AACA,aAAI,mBAAmB,eAAe,eAAf,CAA+B,UAA/B,EAA2C,cAA3C,CAAvB;;AAEA,aAAI,qBAAqB,CAAC,CAA1B,EAA6B;AAC1B,0BAAc,IAAd,CAAmB,WAAW,gBAAX,CAAnB;AACF;AACH;;;AAGD,UAAI,eAAe,eAAe,eAAf,CAA+B,aAA/B,EAA8C,cAA9C,CAAnB;;AAEA,aAAO;AACJ,kBAAS,aAAa,KAAb,IAAsB,CAAtB,GAA0B,cAAc,aAAa,KAA3B,CAA1B,GAA8D;AADnE,OAAP;AAGF;;;;;;;;;;;AAWD,YAAS,WAAT,CAAqB,cAArB,EAAqC,OAArC,EAA8C,cAA9C,EAA8D;AAC3D,UAAI,OAAO,EAAX;;AAEA,UAAI,YAAY,oBAAhB,EAAsC;AACnC,iBAAQ,KAAR,CAAc,mCAAd;AACA,gBAAO,mBAAmB,cAAnB,EAAmC,cAAnC,CAAP;AACF,OAHD,MAGO,IAAI,YAAY,uBAAhB,EAAyC;AAC7C,iBAAQ,KAAR,CAAc,8BAAd;AACA,gBAAO,uBAAuB,cAAvB,EAAuC,cAAvC,CAAP;AACF;;AAED,aAAO,IAAP;AACF;;;;;;;;OAQgB,Q;;;;;;;;;AAQd,wBAAY,QAAZ,EAAsB;AAAA;;AACnB,aAAI,EAAE,SAAS,SAAT,oCAAF,CAAJ,EAAqD;AAClD,kBAAM,IAAI,SAAJ,CAAiB,UAAU,CAAV,CAAjB,2CAAN;AACF;;AAED,gBAAO,cAAP,CAAsB,IAAtB,EAA4B,gBAA5B,EAA8C;AAC3C,wBAAY,KAD+B;AAE3C,0BAAc,KAF6B;AAG3C,iBAAK,eAAW;AACb,sBAAO,QAAP;AACF;AAL0C,UAA9C;AAOF;;;;;;;;;;;;;;;0CAWgB,c,EAAgB,kB,EAAoB;AAClD,gBAAI,cAAc,OAAO,iBAAzB;AACA,gBAAI,WAAW,mBAAmB,QAAlC;AACA,gBAAI,qBAAJ;;AAEA,0BAAc,kBAAd;AACA,6BAAiB,eAAe,iBAAf,EAAjB;;AAEA,oBAAQ,KAAR,CAAc,6BAAd;;AAEA,iBAAI,IAAI,OAAR,IAAmB,QAAnB,EAA6B;AAC1B,mBAAI,cAAc,KAAK,cAAL,CAAoB,eAApB,CACf,CAAC,SAAS,OAAT,EAAkB,IAAnB,EAAyB,MAAzB,CAAgC,SAAS,OAAT,EAAkB,UAAlD,CADe,EAEf,cAFe,CAAlB;;AAKA,mBAAI,YAAY,QAAZ,GAAuB,WAA3B,EAAwC;AACrC,iCAAe,OAAO,MAAP,CAAc;AAC1B;AAD0B,mBAAd,EAEZ,YAAY,KAAK,cAAjB,EAAiC,OAAjC,EAA0C,cAA1C,CAFY,CAAf;;AAIA,sBAAI,YAAY,QAAZ,KAAyB,CAA7B,EAAgC;AAC7B;AACF,mBAFD,MAEO;AACJ,mCAAc,YAAY,QAA1B;AACF;AACH;AACH;;AAED,oBAAQ,KAAR,gDAA2D,SAAS,aAAa,OAAtB,EAA+B,IAA1F;AACA,oBAAQ,KAAR,CAAc,oBAAd,EAAoC,YAApC;;AAEA,mBAAO,YAAP;AACF;;;;;;qBAhEa,Q;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5IjB,YAAS,QAAT,GAAoB;AACjB,aAAO,SAAS,KAAhB;AACF;;WAGE,Q,GAAA,Q;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACCH,YAAS,gBAAT,CAA0B,OAA1B,EAAmC;AAChC,UAAI,EAAE,mBAAmB,WAArB,CAAJ,EAAuC;AACpC;AACF;;AAED,cAAQ,SAAR,cAA6B,QAAQ,SAArC;AACF;;;;;;;;AAQD,YAAS,kBAAT,CAA4B,OAA5B,EAAqC;AAClC,UAAI,EAAE,mBAAmB,WAArB,CAAJ,EAAuC;AACpC;AACF;;AAED,cAAQ,SAAR,GAAoB,QAAQ,SAAR,CAChB,OADgB,CACR,SADQ,EACG,EADH,EAEhB,OAFgB,CAER,WAFQ,EAEK,EAFL,CAApB;AAGF;;qBAGQ;AACN,qCADM;AAEN,+BAFM;AAGN,4BAHM;AAIN,kCAJM;AAKN,wCALM;AAMN;AANM,I;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5BT,YAAS,cAAT,CAAwB,OAAxB,EAAiC;AAC9B,UAAI,CAAC,OAAD,IAAY,CAAC,QAAQ,QAArB,IAAiC,QAAQ,QAAR,CAAiB,WAAjB,GAA+B,OAA/B,CAAuC,GAAvC,MAAgD,CAArF,EAAwF;AACrF,gBAAO,CAAP;AACF;;AAED,aAAO,SAAS,QAAQ,QAAR,CAAiB,MAAjB,CAAwB,CAAxB,CAAT,EAAqC,EAArC,CAAP;AACF;;;;;;;;;;;;AAYD,YAAS,uBAAT,CAAiC,OAAjC,EAA0C;AACvC,UAAI,OAAO,EAAX;;AAEA,OAAC,SAAS,OAAT,CAAiB,OAAjB,EAA0B,KAA1B,EAAiC,IAAjC,EAAuC;AACrC,aAAI,MAAM,KAAN,KAAgB,QAAQ,MAA5B,EAAoC;AACjC,mBAAO,IAAP;AACF;;AAED,aAAI,cAAc,eAAe,QAAQ,MAAM,KAAd,CAAf,CAAlB;AACA,aAAI,SAAS;AACV,qBAAS,QAAQ,MAAM,KAAd,CADC;AAEV,yBAAa;AAFH,UAAb;;AAKA,aAAI,KAAK,MAAL,KAAgB,CAAhB,IAAqB,gBAAgB,eAAe,KAAK,KAAK,MAAL,GAAc,CAAnB,EAAsB,OAArC,CAAzC,EAAwF;AACrF,iBAAK,IAAL,CAAU,MAAV;AACA,kBAAM,KAAN;;AAEA,mBAAO,QAAQ,OAAR,EAAiB,KAAjB,EAAwB,IAAxB,CAAP;AACF;;AAED,aAAI,cAAc,eAAe,KAAK,KAAK,MAAL,GAAc,CAAnB,EAAsB,OAArC,CAAlB,EAAiE;AAC9D,iBAAK,KAAK,MAAL,GAAc,CAAnB,EAAsB,WAAtB,GAAoC,QAAQ,OAAR,EAAiB,KAAjB,EAAwB,EAAxB,CAApC;AACF;;AAED,uBAAc,eAAe,QAAQ,MAAM,KAAd,CAAf,CAAd;;AAEA,aAAI,gBAAgB,eAAe,KAAK,KAAK,MAAL,GAAc,CAAnB,EAAsB,OAArC,CAApB,EAAmE;AAChE,mBAAO,QAAQ,OAAR,EAAiB,KAAjB,EAAwB,IAAxB,CAAP;AACF,UAFD,MAEO;AACJ,mBAAO,IAAP;AACF;AACH,OA7BD,EA6BG,OA7BH,EA6BY;AACT,gBAAO;AADE,OA7BZ,EA+BG,IA/BH;;AAiCA,aAAO,IAAP;AACF;;;;;;;;;;;;AAYD,YAAS,UAAT,GAAkC;AAAA,UAAd,OAAc,yDAAJ,EAAI;;AAC/B,UAAI,iBAAJ;;AAEA,gBAAU,OAAO,MAAP,CACP;AACG,gBAAO,CAAC,CADX;AAEG,eAAM;AAFT,OADO,EAKP,OALO,CAAV;;AAQA,UAAI,QAAQ,KAAR,KAAkB,CAAC,CAAvB,EAA0B;AACvB,oBAAW,wBAAX;AACF,OAFD,MAEO;AACJ,0BAAe,QAAQ,KAAvB;AACF;;AAED,UAAI,mBAAmB,IAAI,MAAJ,aAAqB,QAAQ,IAA7B,cAA4C,GAA5C,CAAvB;AACA,UAAI,UAAU,MACV,IADU,CACL,SAAS,gBAAT,CAA0B,QAA1B,CADK,EAEV,MAFU,CAEH;AAAA,gBAAU,OAAO,WAAP,CAAmB,MAAnB,CAA0B,gBAA1B,KAA+C,CAAzD;AAAA,OAFG,CAAd;;AAIA,aAAO,OAAP;AACF;;WAGE,uB,GAAA,uB;WACA,U,GAAA,U;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/FH,YAAS,qBAAT,CAA+B,OAA/B,EAAwC;AACrC,aAAO,OAAO,gBAAP,CAAwB,OAAxB,EAAiC,OAAjC,KAA6C,MAA7C,IACA,QAAQ,YAAR,CAAqB,aAArB,MAAwC,MAD/C;AAEF;;;;;;;;;;AAUD,YAAS,QAAT,GAAgC;AAAA,UAAd,OAAc,yDAAJ,EAAI;;AAC7B,gBAAU,OAAO,MAAP,CACP;AACG,mBAAU;AADb,OADO,EAIP,OAJO,CAAV;;AAOA,UAAI,QAAQ,QAAQ,QAAR,CAAiB,gBAAjB,CAAkC,GAAlC,CAAZ;;AAEA,aAAO,MACH,IADG,CACE,KADF,EAEH,MAFG,CAEI;AAAA,gBAAW,sBAAsB,OAAtB,CAAX;AAAA,OAFJ,CAAP;AAGF;;WAGE,Q,GAAA,Q;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7BH,YAAS,OAAT,GAAmB;AAChB,UAAI,OAAO,SAAS,aAAT,CAAuB,MAAvB,KACA,SAAS,aAAT,CAAuB,eAAvB,CADX;;;;AAKA,UAAI,CAAC,IAAL,EAAW;AACR,aAAI,eAAe,SAAS,gBAAT,CAA0B,4CAA1B,CAAnB;;;;AAIA,aAAI,aAAa,MAAb,KAAwB,CAA5B,EAA+B;AAC5B,mBAAO,aAAa,CAAb,CAAP;AACF;AACH;;AAED,aAAO,IAAP;AACF;;WAGE,O,GAAA,O;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;OCrBc,Y;;;;;;;wCAiBQ,S,EAAW;AAC9B,mBAAU,aAAa,SAAvB,SAAoC,SAApC;AACF;;;mCASgB,S,EAAW,O,EAA0B;AAAA,gBAAjB,UAAiB,yDAAJ,EAAI;;AACnD,gBAAI,cAAc,SAAS,WAAT,CAAqB,OAArB,CAAlB;;AAEA,wBAAY,SAAZ,CAAsB,SAAtB,EAAiC,IAAjC,EAAuC,IAAvC;;AAEA,mBACI,mBADJ,CACwB,UADxB,EAEI,OAFJ,CAEY;AAAA,sBAAY,YAAY,QAAZ,IAAwB,WAAW,QAAX,CAApC;AAAA,aAFZ;;AAIA,oBAAQ,aAAR,CAAsB,WAAtB;AACF;;;6BAhCsB;AACpB,mBAAO,WAAP;AACF;;;;;;qBARa,Y;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;OCGA,0B;;;;;;;;;;;yCASS,M,EAAQ,M,EAAQ;AACpC,gBAAI,CAAC,MAAM,OAAN,CAAc,MAAd,CAAL,EAA4B;AACzB,wBAAS,CAAC,MAAD,CAAT;AACF;;AAED,gBAAI,qBAAqB,mCAAzB,C;AACA,gBAAI,cAAc,OAAO,iBAAzB;AACA,gBAAI,QAAQ,CAAC,CAAb;;AAEA,iBAAI,IAAI,IAAI,CAAZ,EAAe,IAAI,OAAO,MAA1B,EAAkC,GAAlC,EAAuC;AACpC,mBAAI,WAAW,mBAAmB,OAAO,CAAP,CAAnB,EAA8B,MAA9B,CAAf;;AAEA,uBAAQ,KAAR,4BAAuC,OAAO,CAAP,CAAvC,eAA0D,MAA1D,aAAwE,QAAxE;;AAEA,mBAAI,aAAa,CAAb,IAAkB,WAAW,WAAjC,EAA8C;AAC3C,gCAAc,QAAd;AACA,0BAAQ,CAAR;;;AAGA,sBAAI,aAAa,CAAjB,EAAoB;AACjB;AACF;AACH;AACH;;AAED,mBAAO;AACJ,sBAAO,KADH;AAEJ,yBAAU;AAFN,aAAP;AAIF;;;;;;qBAtCa,0B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;OCHA,c;;;;;;;yCAYY,M,EAAQ,M,EAAQ;AACpC,kBAAM,IAAI,KAAJ,UAAiB,UAAU,MAAV,CAAiB,IAAlC,kCAAN;AACF;;;;;;qBAdU,c;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MCAA,K;;;;;;;2BAQF,Y,EAAc;AACvB,eAAO,IAAI,OAAJ,CAAY;AAAA,iBAAW,OAAO,UAAP,CAAkB,OAAlB,EAA2B,YAA3B,CAAX;AAAA,SAAZ,CAAP;AACF;;;;;;oBAVa,K;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACKjB,OAAM,kBAAkB,OAAxB;;;;;;;;;;;;;;;;;AAiBA,OAAM,WAAW;AACd,aAAO,GADO;AAEd,wBAAkB,EAFJ;AAGd,kBAAY;AACT,eAAM;AADG,OAHE;AAMd,eAAS;AACN,eAAM,eADA;AAEN,gBAAO;AAFD;AANK,IAAjB;;AAYA,OAAM,eAAe;AAClB,qBAAe,KADG;AAElB,gBAAU,IAFQ;AAGlB,oBAAc,CAAC;AAHG,IAArB;;AAMA,OAAI,oBAAoB,IAAI,OAAJ,EAAxB;AACA,OAAI,YAAY,IAAI,OAAJ,EAAhB;AACA,OAAI,eAAe,IAAI,GAAJ,CAAQ,CAAC,CAAC,eAAD,iBAAD,CAAR,CAAnB;;;;;;;;;;AAUA,YAAS,mBAAT,CAA6B,gBAA7B,EAA+C,QAA/C,EAAyD;AACtD,aAAO,OACH,KADG,CACM,gBADN,SAC0B,QAD1B,YAEH,IAFG,CAEE;AAAA,gBAAY,SAAS,IAAT,EAAZ;AAAA,OAFF,EAGH,IAHG,CAGE,oBAAY;AACf,sBAAa,GAAb,CAAiB,QAAjB,EAA2B,QAA3B;;AAEA,gBAAO,QAAP;AACF,OAPG,CAAP;AAQF;;;;;;;;AAQD,YAAS,eAAT,CAAyB,SAAzB,EAAoC,KAApC,EAA2C;AACxC,UACG,MAAM,OAAN,KAAkB,IAAlB,KACC,MAAM,IAAN,IAAc,MAAM,IAAN,KAAe,OAA7B,IAAwC,MAAM,KAAN,KAAgB,EADzD,CADH,EAGE;AACC,aAAI,UAAU,aAAV,EAAJ,EAA+B;AAC5B,gBAAI,QAAQ,UAAU,GAAV,CAAc,SAAd,CAAZ;;AAEA,gBAAI,MAAM,QAAV,EAAoB;AACjB,6BAAI,kBAAJ,CAAuB,MAAM,QAAN,CAAe,MAAM,YAArB,CAAvB;AACF;;AAED,sBAAU,WAAV;AACF,UARD,MAQO;AACJ,sBAAU,cAAV;AACF;AACH;AACH;;;;;;;;OAQgB,S;;;;;;;;;AAQd,2BAA0B;AAAA;;AAAA,aAAd,OAAc,yDAAJ,EAAI;;AAAA;;;;;AAIvB,cAAK,QAAL,GAAgB,OAAO,MAAP,CAAc,EAAd,EAAkB,QAAlB,EAA4B,OAA5B,CAAhB;;;;;AAKA,cAAK,UAAL,GAAkB,yBAAe,KAAK,QAAL,CAAc,UAA7B,CAAlB;;;;;AAKA,cAAK,OAAL,GAAe,sBAAY,KAAK,QAAL,CAAc,OAA1B,CAAf;;AAEA,mBAAU,GAAV,CAAc,IAAd,EAAoB,OAAO,MAAP,CAAc,EAAd,EAAkB,YAAlB,CAApB;AACA,2BAAkB,GAAlB,CAAsB,IAAtB,EAA4B,IAAI,GAAJ,EAA5B;;AAEA,aAAI,WAAW,KAAK,QAAL,CAAc,UAAd,CAAyB,IAAxC;;AAEA,aAAI,YAAY,CAAC,aAAa,GAAb,CAAiB,QAAjB,CAAjB,EAA6C;AAC1C,gCAAoB,KAAK,QAAL,CAAc,gBAAlC,EAAoD,QAApD,EACI,IADJ,CAEM,YAAM;AACH,mBAAI,yBAAuB,QAAvB,0BAAJ;;AAEA,uBAAQ,KAAR,CAAc,OAAd;;AAEA,sCAAa,SAAb,CAA0B,uBAAa,SAAvC,wBAAqE,QAArE,EAA+E;AAC5E,wBAAM;AACH,2BAAM;AADH;AADsE,gBAA/E;;AAMA,sBAAO,MAAK,OAAL,CAAa,KAAb,CAAmB,OAAnB,CAAP;AACF,aAdP,EAeM,eAAO;AACJ,uBAAQ,KAAR,CAAc,IAAI,OAAlB;;AAEA,sCAAa,SAAb,CAA0B,uBAAa,SAAvC,qBAAkE,QAAlE,EAA4E;AACzE,wBAAM;AACH,2BAAM;AADH;AADmE,gBAA5E;;AAMA,sBAAO,MAAK,OAAL,CAAa,KAAb,uCAAuD,QAAvD,sBAAP;AACF,aAzBP;AA2BF;AACH;;;;;;;;;;;yCAOe;AACb,mBAAO,UAAU,GAAV,CAAc,IAAd,EAAoB,aAA3B;AACF;;;2CAOiB;AACf,gBAAI,iBAAiB,kBAAkB,GAAlB,CAAsB,IAAtB,CAArB;;AAEA,2BAAe,GAAf,CAAmB,SAAnB,EAA8B,gBAAgB,IAAhB,CAAqB,IAArB,EAA2B,IAA3B,CAA9B;;AAEA,qBAAS,eAAT,CAAyB,gBAAzB,CAA0C,SAA1C,EAAqD,eAAe,GAAf,CAAmB,SAAnB,CAArD;;AAEA,mBAAO,IAAP;AACF;;;4CAOkB;AAChB,gBAAI,iBAAiB,kBAAkB,GAAlB,CAAsB,IAAtB,CAArB;;AAEA,qBAAS,eAAT,CAAyB,mBAAzB,CAA6C,SAA7C,EAAwD,eAAe,GAAf,CAAmB,SAAnB,CAAxD;AACA,2BAAe,MAAf,CAAsB,SAAtB;;AAEA,mBAAO,IAAP;AACF;;;0CAQgB;AAAA;;AACd,sBAAU,GAAV,CAAc,IAAd,EAAoB,aAApB,GAAoC,IAApC;AACA,oBAAQ,KAAR,CAAc,qBAAd;;AAEA,mCAAa,SAAb,CAA0B,uBAAa,SAAvC,wBAAqE,QAArE;;AAEA,mBAAO,KAAK,OAAL,CACH,KADG,CACG,OADH,EAEH,IAFG,CAEE;AAAA,sBAAM,OAAK,UAAL,CAAgB,SAAhB,EAAN;AAAA,aAFF,EAGH,IAHG,CAGE,0BAAkB;AACrB,mBAAI,WAAW,4DAAf;AACA,mBAAI,cAAc,aAAa,GAAb,CAAiB,OAAK,QAAL,CAAc,UAAd,CAAyB,IAA1C,CAAlB;;AAEA,sBAAO,SAAS,gBAAT,CAA0B,cAA1B,EAA0C,WAA1C,CAAP;AACF,aARG,EASH,IATG,CASE;AAAA,sBAAqB,iBAAO,KAAP,SAAmB,iBAAnB,CAArB;AAAA,aATF,EAUH,KAVG,CAUG,iBAAS;AACb,mBAAI,yCAAJ,EAAqC;AAClC,yBAAO,OAAK,OAAL,CAAa,KAAb,CAAmB,MAAM,OAAzB,CAAP;AACF;;AAED,mBAAI,MAAM,KAAN,KAAgB,SAAhB,IAA6B,MAAM,KAAN,KAAgB,aAAjD,EAAgE;AAC7D,0BAAQ,KAAR,CAAc,mBAAd,EAAmC,KAAnC;;AAEA,4BAAU,GAAV,SAAoB,OAAO,MAAP,CAAc,EAAd,EAAkB,YAAlB,CAApB;;AAEA,yBAAO,OAAK,OAAL,CAAa,KAAb,CAAmB,0CAAnB,CAAP;AACF;AACH,aAtBG,EAuBH,IAvBG,C;AAwBD,wBAAM,CAAE,CAxBP,EAyBD,YAAM,CAAE,CAzBP,EA2BH,IA3BG,CA2BE,YAAM;AACT,yBAAU,GAAV,SAAoB,aAApB,GAAoC,KAApC;AACA,uBAAQ,KAAR,CAAc,uBAAd;;AAEA,sCAAa,SAAb,CAA0B,uBAAa,SAAvC,sBAAmE,QAAnE;AACF,aAhCG,CAAP;AAiCF;;;uCAKa;AACX,iBAAK,UAAL,CAAgB,KAAhB;AACA,iBAAK,OAAL,CAAa,MAAb;AACA,sBAAU,GAAV,CAAc,IAAd,EAAoB,aAApB,GAAoC,KAApC;AACA,oBAAQ,KAAR,CAAc,qBAAd;AACF;;;uCAYyB;AAAA;;AAAA,gBAAd,OAAc,yDAAJ,EAAI;;AACvB,gBAAI,UAAU,cAAI,UAAJ,CAAe,OAAf,CAAd;AACA,gBAAI,QAAQ,WAAW,QAAQ,KAAnB,GAA2B,QAAQ,KAAnC,GAA2C,CAAC,CAAxD;;AAEA,sBAAU,GAAV,CAAc,IAAd,EAAoB,QAApB,GAA+B,OAA/B;;AAEA,mBAAO,QAAQ,MAAR,CAAe,UAAC,OAAD,EAAU,MAAV,EAAkB,KAAlB,EAA4B;AAC/C,yBAAU,QAAQ,IAAR,CAAa,YAAM;AAC1B,4BAAU,GAAV,SAAoB,YAApB,GAAmC,KAAnC;AACA,gCAAI,gBAAJ,CAAqB,MAArB;;AAEA,yBAAO,OAAK,OAAL,CACH,KADG,CACG,OAAO,WAAP,IAAsB,UAAU,CAAC,CAAX,GAAe,EAAf,SAAwB,OAAO,QAArD,CADH,EAEH,IAFG,CAEE;AAAA,4BAAM,cAAI,kBAAJ,CAAuB,MAAvB,CAAN;AAAA,mBAFF,EAGH,KAHG,CAGG,iBAAS;AACb,mCAAI,kBAAJ,CAAuB,MAAvB;;AAEA,4BAAO,QAAQ,MAAR,CAAe,KAAf,CAAP;AACF,mBAPG,CAAP;AAQF,gBAZS,CAAV;;AAcA,mBAAI,OAAK,QAAL,CAAc,KAAd,GAAsB,CAA1B,EAA6B;AAC1B,4BAAU,QAAQ,IAAR,CAAa;AAAA,4BAAM,gBAAM,IAAN,CAAW,OAAK,QAAL,CAAc,KAAzB,CAAN;AAAA,mBAAb,CAAV;AACF;;AAED,sBAAO,OAAP;AACF,aApBM,EAoBJ,QAAQ,OAAR,EApBI,CAAP;AAqBF;;;8CAOoB;AAClB,gBAAI,QAAQ,UAAU,GAAV,CAAc,IAAd,CAAZ;;AAEA,gBAAI,CAAC,MAAM,QAAX,EAAqB;AAClB,sBAAO,QAAQ,MAAR,CAAe,6BAAmB,wCAAnB,CAAf,CAAP;AACF;;AAED,gBAAI,UAAU,MAAM,QAAN,CAAe,MAAM,YAArB,CAAd;;AAEA,0BAAI,gBAAJ,CAAqB,OAArB;;AAEA,mBAAO,KAAK,OAAL,CACH,KADG,CACG,QAAQ,WADX,EAEH,IAFG,CAEE;AAAA,sBAAM,cAAI,kBAAJ,CAAuB,OAAvB,CAAN;AAAA,aAFF,EAGH,KAHG,CAGG,iBAAS;AACb,6BAAI,kBAAJ,CAAuB,OAAvB;;AAEA,sBAAO,QAAQ,MAAR,CAAe,KAAf,CAAP;AACF,aAPG,CAAP;AAQF;;;+CAOqB;AACnB,gBAAI,QAAQ,UAAU,GAAV,CAAc,IAAd,CAAZ;;AAEA,gBAAI,MAAM,YAAN,KAAuB,CAA3B,EAA8B;AAC3B,sBAAO,QAAQ,MAAR,CAAe,6BAAmB,kCAAnB,CAAf,CAAP;AACF;;AAED,kBAAM,YAAN;;AAEA,mBAAO,KAAK,kBAAL,EAAP;AACF;;;2CAOiB;AACf,gBAAI,QAAQ,UAAU,GAAV,CAAc,IAAd,CAAZ;;AAEA,gBAAI,MAAM,YAAN,KAAuB,MAAM,QAAN,CAAe,MAAf,GAAwB,CAAnD,EAAsD;AACnD,sBAAO,QAAQ,MAAR,CAAe,6BAAmB,iCAAnB,CAAf,CAAP;AACF;;AAED,kBAAM,YAAN;;AAEA,mBAAO,KAAK,kBAAL,EAAP;AACF;;;oCAOU;AACR,gBAAI,QAAQ,UAAU,GAAV,CAAc,IAAd,CAAZ;AACA,gBAAI,iBAAiB,MAAM,QAAN,GAAiB,MAAM,QAAN,CAAe,MAAM,YAArB,CAAjB,GAAsD,IAA3E;;AAEA,gBAAI,CAAC,cAAD,IAAmB,eAAe,QAAf,KAA4B,GAAnD,EAAwD;AACrD,qBAAM,6BAAmB,uCAAnB,CAAN;AACF;;AAED,mBAAO,QAAP,CAAgB,MAAhB,CAAuB,eAAe,IAAtC;AACF;;;mCASS,O,EAAS;AAAA;;AAChB,gBAAI,QAAQ,cAAI,QAAJ,CAAa,OAAb,CAAZ;;AAEA,sBAAU,GAAV,CAAc,IAAd,EAAoB,QAApB,GAA+B,KAA/B;;AAEA,mBAAO,MAAM,MAAN,CAAa,UAAC,OAAD,EAAU,IAAV,EAAgB,KAAhB,EAA0B;AAC3C,yBAAU,QAAQ,IAAR,CAAa,YAAM;AAC1B,4BAAU,GAAV,SAAoB,YAApB,GAAmC,KAAnC;;AAEA,yBAAO,OAAK,kBAAL,EAAP;AACF,gBAJS,CAAV;;AAMA,mBAAI,OAAK,QAAL,CAAc,KAAd,GAAsB,CAA1B,EAA6B;AAC1B,4BAAU,QAAQ,IAAR,CAAa;AAAA,4BAAM,gBAAM,IAAN,CAAW,OAAK,QAAL,CAAc,KAAzB,CAAN;AAAA,mBAAb,CAAV;AACF;;AAED,sBAAO,OAAP;AACF,aAZM,EAYJ,QAAQ,OAAR,EAZI,CAAP;AAaF;;;oCAOU;AACR,gBAAI,OAAO,cAAI,OAAJ,EAAX;AACA,gBAAI,QAAQ,UAAU,GAAV,CAAc,IAAd,CAAZ;;AAEA,kBAAM,QAAN,GAAiB,CAAC,IAAD,CAAjB;AACA,kBAAM,YAAN,GAAqB,CAArB;;AAEA,gBAAI,CAAC,IAAL,EAAW;AACR,sBAAO,QAAQ,MAAR,CAAe,6BAAmB,+CAAnB,CAAf,CAAP;AACF;;AAED,mBAAO,KAAK,OAAL,CAAa,KAAb,CAAmB,KAAK,WAAxB,CAAP;AACF;;;sCAOY;AACV,gBAAI,OAAO,cAAI,OAAJ,EAAX;;AAEA,gBAAI,CAAC,IAAL,EAAW;AACR,qBAAM,6BAAmB,kDAAnB,CAAN;AACF;;AAED,gBAAI,cAAc,KAAK,YAAL,CAAkB,UAAlB,CAAlB;;AAEA,iBAAK,YAAL,CAAkB,UAAlB,EAA8B,CAAC,CAA/B;AACA,iBAAK,gBAAL,CAAsB,MAAtB,EAA8B,SAAS,cAAT,GAA0B;AACrD,oBAAK,mBAAL,CAAyB,MAAzB,EAAiC,cAAjC;;;AAGA,mBAAI,WAAJ,EAAiB;AACd,uBAAK,YAAL,CAAkB,UAAlB,EAA8B,WAA9B;AACF,gBAFD,MAEO;AACJ,uBAAK,eAAL,CAAqB,UAArB;AACF;AACH,aATD;AAUA,iBAAK,KAAL;AACF;;;yCAOe;AACb,gBAAI,QAAQ,cAAI,QAAJ,EAAZ;;AAEA,gBAAI,KAAJ,EAAW;AACR,sBAAO,KAAK,OAAL,CAAa,KAAb,+BAA+C,KAA/C,CAAP;AACF,aAFD,MAEO;AACJ,sBAAO,KAAK,OAAL,CAAa,KAAb,CAAmB,iCAAnB,CAAP;AACF;AACH;;;2CAOiB;AACf,gBAAI,UAAU,cAAI,UAAJ,EAAd;AACA,gBAAI,QAAQ,cAAI,QAAJ,EAAZ;;AAEA,mBAAO,KAAK,OAAL,CAAa,KAAb,wBAAwC,QAAQ,MAAhD,qBAAsE,MAAM,MAA5E,YAAP;AACF;;;4CAOkB;AAChB,mBAAO,IAAI,OAAJ,CAAY,UAAC,OAAD,EAAU,MAAV,EAAqB;AACrC,wBAAS,UAAT,GAAsB;AACnB,yBAAO,mBAAP,CAA2B,UAA3B,EAAuC,UAAvC;AACA;AACF;;AAED,sBAAO,gBAAP,CAAwB,UAAxB,EAAoC,UAApC;AACA,sBAAO,OAAP,CAAe,IAAf;;;;;;;;;;;AAWA,0BAAW,YAAM;AACd,yBAAO,6BAAmB,gCAAnB,CAAP;AACA,yBAAO,mBAAP,CAA2B,UAA3B,EAAuC,UAAvC;AACF,gBAHD,EAGG,EAHH;AAIF,aAtBM,CAAP;AAuBF;;;wCAOc;AACZ,mBAAO,IAAI,OAAJ,CAAY,UAAC,OAAD,EAAU,MAAV,EAAqB;AACrC,wBAAS,UAAT,GAAsB;AACnB,yBAAO,mBAAP,CAA2B,UAA3B,EAAuC,UAAvC;AACA;AACF;;AAED,sBAAO,gBAAP,CAAwB,UAAxB,EAAoC,UAApC;AACA,sBAAO,OAAP,CAAe,OAAf;;;;AAIA,0BAAW,YAAM;AACd,yBAAO,6BAAmB,+BAAnB,CAAP;AACA,yBAAO,mBAAP,CAA2B,UAA3B,EAAuC,UAAvC;AACF,gBAHD,EAGG,EAHH;AAIF,aAfM,CAAP;AAgBF;;;wCAKc;AACZ,mBAAO,QAAP,CAAgB,MAAhB,CAAuB,GAAvB;AACF;;;;;;qBA/aa,S;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3EjB,YAAS,aAAT,GAAyB;AACtB,aAAO,OAAO,iBAAP,IACA,OAAO,uBADP,IAEA,IAFP;AAGF;;;;;;;;;AASD,YAAS,UAAT,CAAoB,UAApB,EAAgC,UAAhC,EAA4C;AACzC,WAAI,IAAI,SAAR,IAAqB,UAArB,EAAiC;AAC9B,oBAAW,gBAAX,CAA4B,SAA5B,EAAuC,WAAW,SAAX,CAAvC;AACF;AACH;;;;;;;;;AASD,YAAS,YAAT,CAAsB,UAAtB,EAAkC,UAAlC,EAA8C;AAC3C,WAAI,IAAI,SAAR,IAAqB,UAArB,EAAiC;AAC9B,oBAAW,mBAAX,CAA+B,SAA/B,EAA0C,WAAW,SAAX,CAA1C;AACF;AACH;;;;;;;;OAQc,U;;;;;;;;;AAQZ,4BAAwB;AAAA,aAAZ,OAAY,yDAAJ,EAAI;;AAAA;;AACrB,aAAI,cAAa,eAAjB;;AAEA,aAAI,CAAC,WAAL,EAAiB;AACd,kBAAM,MAAM,mBAAN,CAAN;AACF;;;;;;;AAOD,cAAK,UAAL,GAAkB,IAAI,WAAJ,EAAlB;;AAEA,cAAI,IAAI,GAAR,IAAe,OAAf,EAAwB;AACrB,gBAAI,QAAQ,cAAR,CAAuB,GAAvB,KAA+B,KAAK,UAAL,CAAgB,GAAhB,MAAyB,SAA5D,EAAuE;AACpE,oBAAK,UAAL,CAAgB,GAAhB,IAAuB,QAAQ,GAAR,CAAvB;AACF;AACH;AACH;;;;;;;;;;;qCAgBW;AAAA;;AACT,mBAAO,IAAI,OAAJ,CAAY,UAAC,OAAD,EAAU,MAAV,EAAqB;AACrC,mBAAI,aAAa,MAAK,UAAtB;AACA,mBAAI,aAAa;AACd,8BAAY,sBAAM;AACf,4CAAa,SAAb,CAA0B,uBAAa,SAAvC,wBAAqE,QAArE;AACF,mBAHa;AAId,0BAAQ,uBAAS;AACd,0BAAI,IAAI,IAAI,MAAM,WAAlB,EAA+B,IAAI,MAAM,OAAN,CAAc,MAAjD,EAAyD,GAAzD,EAA8D;AAC3D,4BAAI,MAAM,OAAN,CAAc,CAAd,EAAiB,OAArB,EAA8B;AAC3B,+BAAI,YAAY,MAAM,OAAN,CAAc,CAAd,EAAiB,CAAjB,CAAhB;;AAEA,mCAAQ,KAAR,CAAc,uBAAd;AACA,mCAAQ,KAAR,kBAA6B,UAAU,UAAvC,+BAA2E,UAAU,UAArF;;AAEA,kDAAa,SAAb,CAA0B,uBAAa,SAAvC,yBAAsE,QAAtE,EAAgF;AAC7E,oCAAM;AACH,yCAAQ;AADL;AADuE,4BAAhF;;AAMA,mCAAQ,UAAU,UAAlB;AACF;AACH;AACH,mBArBa;AAsBd,yBAAO,sBAAS;AACb,6BAAQ,KAAR,CAAc,oBAAd,EAAoC,MAAM,KAA1C;;AAEA,4CAAa,SAAb,CAA0B,uBAAa,SAAvC,wBAAqE,QAArE,EAA+E;AAC5E,+BAAO,MAAM;AAD+D,sBAA/E;;AAIA,4BAAO,6BAAmB,qDAAnB,CAAP;AACF,mBA9Ba;AA+Bd,2BAAS,mBAAM;AACZ,6BAAQ,KAAR,CAAc,sCAAd;;AAEA,4CAAa,SAAb,CAA0B,uBAAa,SAAvC,0BAAuE,QAAvE;;AAEA,4BAAO,6BAAmB,iCAAnB,CAAP;AACF,mBArCa;AAsCd,uBAAK,eAAM;AACR,6BAAQ,KAAR,CAAc,mBAAd;;AAEA,4CAAa,SAAb,CAA0B,uBAAa,SAAvC,sBAAmE,QAAnE;;AAEA,kCAAa,UAAb,EAAyB,UAAzB;;;;AAIA,4BAAO,6BAAmB,0CAAnB,CAAP;AACF;AAhDa,gBAAjB;;AAmDA,0BAAW,MAAK,UAAhB,EAA4B,UAA5B;;AAEA,uBAAQ,KAAR,CAAc,qBAAd;AACA,qBAAK,UAAL,CAAgB,KAAhB;AACF,aAzDM,CAAP;AA0DF;;;iCAKO;AACL,iBAAK,UAAL,CAAgB,KAAhB;AACF;;;uCA3EoB;AAClB,mBAAO,CAAC,CAAC,eAAT;AACF;;;;;;qBApCW,U;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtDf,OAAM,oBAAoB,OAAO,aAAP,CAA1B;;;;;;;;;;;;;;;;;;;;;;AAsBA,YAAS,UAAT,GAAsB;AACnB,aAAO,OAAO,eAAP,IACA,IADP;AAEF;;;;;;;;;;AAUD,YAAS,WAAT,CAAqB,MAArB,EAA6B,MAA7B,EAAqC;AAClC,aAAO,OACH,MADG,CACI;AAAA,gBAAS,MAAM,QAAN,KAAmB,MAA5B;AAAA,OADJ,EAEH,GAFG,EAAP;AAGF;;;;;;;;;AASD,YAAS,oBAAT,CAA8B,SAA9B,EAAyC,QAAzC,EAAmD,MAAnD,EAA2D;AACxD,WAAI,IAAI,GAAR,IAAe,QAAf,EAAyB;AACtB,aAAI,CAAC,SAAS,cAAT,CAAwB,GAAxB,CAAD,IAAiC,UAAU,GAAV,MAAmB,SAAxD,EAAmE;AAChE;AACF;;AAED,aAAI,QAAQ,OAAZ,EAAqB;AAClB,sBAAU,GAAV,IAAiB,SAAS,GAAT,CAAjB;AACA;AACF;;AAED,aAAI,QAAQ,YAAY,MAAZ,EAAoB,SAAS,GAAT,CAApB,CAAZ;;AAEA,aAAI,KAAJ,EAAW;AACR,sBAAU,GAAV,IAAiB,KAAjB;AACF,UAFD,MAEO;AACJ,oBAAQ,KAAR,CAAc,oEAAd;AACA,sBAAU,GAAV,IAAiB,OAAO,CAAP,CAAjB;AACF;AACH;AACH;;;;;;;;OAQc,O;;;;;;;;;AAQZ,yBAA0B;AAAA,aAAd,OAAc,yDAAJ,EAAI;;AAAA;;;;;;AAKvB,cAAK,OAAL,GAAe,YAAf;;;;;AAKA,cAAK,QAAL,GAAgB,OAAhB;;;;;AAKA,cAAK,iBAAL,IAA0B,KAA1B;;AAEA,aAAI,CAAC,KAAK,OAAV,EAAmB;AAChB,kBAAM,MAAM,mBAAN,CAAN;AACF;AACH;;;;;;;;;;;qCAgBW;AAAA;;AACT,mBAAO,IAAI,OAAJ,CAAY,mBAAW;AAC3B,mBAAI,SAAS,MAAK,OAAL,CAAa,SAAb,EAAb;;AAEA,mBAAI,OAAO,MAAP,GAAgB,CAApB,EAAuB;AACpB,yBAAO,QAAQ,MAAR,CAAP;AACF,gBAFD,MAEO;AAAA;AACJ,yBAAI,kBAAkB,YAAW;AAC9B,gCAAQ,KAAK,OAAL,CAAa,SAAb,EAAR;;AAEA,qCAAa,mBAAb,CAAiC,eAAjC,EAAkD,eAAlD;AACF,sBAJqB,CAIpB,IAJoB,OAAtB;;AAMA,kCAAa,gBAAb,CAA8B,eAA9B,EAA+C,eAA/C;AAPI;AAQN;AACH,aAdM,CAAP;AAeF;;;+BASK,I,EAAM;AAAA;;AACT,mBAAO,KACH,SADG,GAEH,IAFG,CAEE,kBAAU;AACb,sBAAO,IAAI,OAAJ,CAAY,UAAC,OAAD,EAAU,MAAV,EAAqB;AACrC,sBAAI,YAAY,IAAI,OAAO,wBAAX,CAAoC,IAApC,CAAhB;AACA,sBAAI,YAAY,OAAO,MAAP,CAAc;AAC3B;AAD2B,mBAAd,EAEb,OAAK,QAFQ,CAAhB;;AAIA,uCAAqB,SAArB,EAAgC,OAAK,QAArC,EAA+C,MAA/C;;AAEA,4BAAU,gBAAV,CAA2B,OAA3B,EAAoC,YAAM;AACvC,6BAAQ,KAAR,6BAAwC,IAAxC;;AAEA,4CAAa,SAAb,CAA0B,uBAAa,SAAvC,sBAAmE,QAAnE,EAA6E;AAC1E,8BAAM;AADoE,sBAA7E;AAGF,mBAND;;AAQA,4BAAU,gBAAV,CAA2B,KAA3B,EAAkC,YAAM;AACrC,6BAAQ,KAAR,CAAc,qBAAd;;AAEA,4CAAa,SAAb,CAA0B,uBAAa,SAAvC,oBAAiE,QAAjE,EAA2E;AACxE,8BAAM;AADkE,sBAA3E;;AAIA,yBAAI,OAAK,iBAAL,CAAJ,EAA6B;AAC1B,+BAAK,iBAAL,IAA0B,KAA1B;;AAEA,+BAAO,OAAO;AACX,kCAAO;AADI,yBAAP,CAAP;AAGF;;AAED;AACF,mBAhBD;;AAkBA,4BAAU,gBAAV,CAA2B,OAA3B,EAAoC,iBAAS;AAC1C,6BAAQ,KAAR,CAAc,mBAAd,EAAmC,MAAM,KAAzC;;AAEA,4CAAa,SAAb,CAA0B,uBAAa,SAAvC,sBAAmE,QAAnE,EAA6E;AAC1E,8BAAM;AADoE,sBAA7E;;AAIA,4BAAO,6BAAmB,sCAAnB,CAAP;AACF,mBARD;;AAUA,yBAAK,OAAL,CAAa,KAAb,CAAmB,SAAnB;AACF,gBA7CM,CAAP;AA8CF,aAjDG,CAAP;AAkDF;;;kCAKQ;AACN,iBAAK,OAAL,CAAa,MAAb;AACA,iBAAK,iBAAL,IAA0B,IAA1B;AACF;;;uCA7FoB;AAClB,mBAAO,CAAC,CAAC,YAAT;AACF;;;;;;qBArCW,O;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;OC7EA,M;;;;;;;+BASC,S,EAAW,iB,EAAmB;;AAExC,gBAAI,kBAAkB,OAAlB,KAA8B,kBAAlC,EAAsD;AACnD,sBAAO,UAAU,WAAV,EAAP;AACF,aAFD,MAEO,IAAI,kBAAkB,OAAlB,KAA8B,gBAAlC,EAAoD;AACxD,sBAAO,UAAU,SAAV,EAAP;AACF,aAFM,MAEA,IAAI,kBAAkB,OAAlB,KAA8B,oBAAlC,EAAwD;AAC5D,sBAAO,UAAU,WAAV,CAAsB;AAC1B,yBAAO,kBAAkB;AADC,gBAAtB,CAAP;AAGF,aAJM,MAIA,IAAI,kBAAkB,OAAlB,KAA8B,WAAlC,EAA+C;AACnD,sBAAO,UAAU,QAAV,EAAP;AACF,aAFM,MAEA,IAAI,kBAAkB,OAAlB,KAA8B,aAAlC,EAAiD;AACrD,sBAAO,IAAI,OAAJ,CAAY,UAAC,OAAD,EAAU,MAAV,EAAqB;AACrC,sBAAI;AACD,6BAAQ,UAAU,UAAV,EAAR;AACF,mBAFD,CAEE,OAAM,EAAN,EAAU;AACT,4BAAO,EAAP;AACF;AACH,gBANM,CAAP;AAOF,aARM,MAQA,IAAI,kBAAkB,OAAlB,KAA8B,YAAlC,EAAgD;AACpD,sBAAO,UAAU,kBAAV,EAAP;AACF,aAFM,MAEA,IAAI,kBAAkB,OAAlB,KAA8B,eAAlC,EAAmD;AACvD,sBAAO,UAAU,mBAAV,EAAP;AACF,aAFM,MAEA,IAAI,kBAAkB,OAAlB,KAA8B,WAAlC,EAA+C;AACnD,sBAAO,UAAU,eAAV,EAAP;AACF,aAFM,MAEA,IAAI,kBAAkB,OAAlB,KAA8B,iBAAlC,EAAqD;AACzD,sBAAO,UAAU,aAAV,EAAP;AACF,aAFM,MAEA,IAAI,kBAAkB,OAAlB,KAA8B,uBAAlC,EAA2D;AAC/D,sBAAO,UAAU,SAAV,CAAoB;AACxB,4BAAU,kBAAkB;AADJ,gBAApB,CAAP;AAGF,aAJM,MAIA,IAAI,kBAAkB,OAAlB,KAA8B,qBAAlC,EAAyD;AAC7D,sBAAO,UAAU,gBAAV,EAAP;AACF,aAFM,MAEA,IAAI,kBAAkB,OAAlB,KAA8B,iBAAlC,EAAqD;AACzD,sBAAO,UAAU,YAAV,EAAP;AACF,aAFM,MAEA,IAAI,kBAAkB,OAAlB,KAA8B,mBAAlC,EAAuD;AAC3D,sBAAO,UAAU,eAAV,EAAP;AACF,aAFM,MAEA,IAAI,kBAAkB,OAAlB,KAA8B,gBAAlC,EAAoD;AACxD,sBAAO,QAAQ,OAAR,CAAgB,UAAU,YAAV,EAAhB,CAAP;AACF,aAFM,MAEA,IAAI,kBAAkB,OAAlB,KAA8B,YAAlC,EAAgD;AACpD,sBAAO,IAAI,OAAJ,CAAY,UAAC,OAAD,EAAU,MAAV,EAAqB;AACrC,sBAAI;AACD,6BAAQ,UAAU,QAAV,EAAR;AACF,mBAFD,CAEE,OAAM,EAAN,EAAU;AACT,4BAAO,EAAP;AACF;AACH,gBANM,CAAP;AAOF,aARM,MAQA;AACJ,sBAAO,QAAQ,MAAR,CAAe,6BAAmB,8BAAnB,CAAf,CAAP;AACF;AACH;;;;;;qBA5DW,M;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MCAA,c;;;;;;;;AAQZ,0BAAY,OAAZ,EAAqB;AAAA;;;;;;;AAMlB,SAAK,IAAL,GAAY,KAAK,WAAL,CAAiB,IAA7B;;;;;;AAMA,SAAK,OAAL,GAAe,OAAf;AACF,G;;oBArBW,c","file":"web-reader.debug.js","sourceRoot":"/source/","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","module.exports={\n   \"commands\": {\n      \"READ_ALL_HEADERS\": {\n         \"text\": \"read all headers\",\n         \"variations\": [\n            \"read headers\",\n            \"read all the headers\"\n         ]\n      },\n      \"READ_ALL_LINKS\": {\n         \"text\": \"read all links\",\n         \"variations\": [\n            \"read links\",\n            \"read all the links\"\n         ]\n      },\n      \"READ_LEVEL_HEADERS\": {\n         \"text\": \"read all h\",\n         \"variations\": [\n            \"read h\",\n            \"read all the h\"\n         ],\n         \"levels\": [\n            \"one\",\n            \"two\",\n            \"three\",\n            \"four\",\n            \"five\",\n            \"six\"\n         ]\n      },\n      \"READ_MAIN\": {\n         \"text\": \"read main content\",\n         \"variations\": [\n            \"read the main\",\n            \"read the main content\"\n         ]\n      },\n      \"SEARCH_MAIN\": {\n         \"text\": \"search main content\",\n         \"variations\": [\n            \"search the main\",\n            \"search the main content\",\n            \"find main content\",\n            \"find the main\",\n            \"find the main content\"\n         ]\n      },\n      \"READ_AGAIN\": {\n         \"text\": \"read element again\",\n         \"variations\": [\n            \"read the current element again\",\n            \"read again\"\n         ]\n      },\n      \"READ_PREVIOUS\": {\n         \"text\": \"read previous element\",\n         \"variations\": [\n            \"read previous\"\n         ]\n      },\n      \"READ_NEXT\": {\n         \"text\": \"read next element\",\n         \"variations\": [\n            \"read next\"\n         ]\n      },\n      \"READ_PAGE_TITLE\": {\n         \"text\": \"read page title\",\n         \"variations\": [\n            \"read title\",\n            \"read the title of the page\",\n            \"read document title\"\n         ]\n      },\n      \"READ_LINKS_IN_ELEMENT\": {\n         \"text\": \"read links inside\",\n         \"variations\": [\n            \"read links contained\",\n            \"read links contained in\",\n            \"read all links inside\",\n            \"read all links contained\",\n            \"read all links contained in\"\n         ]\n      },\n      \"GO_TO_PREVIOUS_PAGE\": {\n         \"text\": \"previous page\",\n         \"variations\": [\n            \"go to previous page\"\n         ]\n      },\n      \"GO_TO_NEXT_PAGE\": {\n         \"text\": \"next page\",\n         \"variations\": [\n            \"go to next page\"\n         ]\n      },\n      \"READ_PAGE_SUMMARY\": {\n         \"text\": \"read page summary\",\n         \"variations\": [\n            \"summarize page\",\n            \"summarize the page\"\n         ]\n      },\n      \"GO_TO_HOMEPAGE\": {\n         \"text\": \"homepage\",\n         \"variations\": [\n            \"go to homepage\"\n         ]\n      },\n      \"GO_TO_LINK\": {\n         \"text\": \"go to link\",\n         \"variations\": [\n            \"follow link\",\n            \"go\",\n            \"go there\"\n         ]\n      }\n   },\n   \"elements\": {\n      \"MAIN\": {\n         \"selector\": \"main\",\n         \"variations\": [\n            \"main\"\n         ]\n      },\n      \"NAV\": {\n         \"selector\": \"nav\",\n         \"variations\": [\n            \"nav\",\n            \"navigation\",\n            \"menu\"\n         ]\n      },\n      \"HEADER\": {\n         \"selector\": \"header\",\n         \"variations\": [\n            \"header\"\n         ]\n      },\n      \"FOOTER\": {\n         \"selector\": \"footer\",\n         \"variations\": [\n            \"footer\"\n         ]\n      }\n   }\n}","function DamerauLevenshtein (prices, damerau) {\n    // 'prices' customisation of the edit costs by passing an\n    // object with optional 'insert', 'remove', 'substitute', and\n    // 'transpose' keys, corresponding to either a constant\n    // number, or a function that returns the cost. The default\n    // cost for each operation is 1. The price functions take\n    // relevant character(s) as arguments, should return numbers,\n    // and have the following form:\n    //\n    // insert: function (inserted) { return NUMBER; }\n    //\n    // remove: function (removed) { return NUMBER; }\n    //\n    // substitute: function (from, to) { return NUMBER; }\n    //\n    // transpose: function (backward, forward) { return NUMBER; }\n    //\n    // The damerau flag allows us to turn off transposition and\n    // only do plain Levenshtein distance.\n\n    if (damerau !== false) damerau = true;\n    if (!prices) prices = {};\n    var insert, remove, substitute, transpose;\n\n    switch (typeof prices.insert) {\n    case 'function': insert = prices.insert; break;\n    case 'number': insert = function (c) { return prices.insert; }; break;\n    default: insert = function (c) { return 1; }; break; }\n\n    switch (typeof prices.remove) {\n    case 'function': remove = prices.remove; break;\n    case 'number': remove = function (c) { return prices.remove; }; break;\n    default: remove = function (c) { return 1; }; break; }\n\n    switch (typeof prices.substitute) {\n    case 'function': substitute = prices.substitute; break;\n    case 'number':\n        substitute = function (from, to) { return prices.substitute; };\n        break;\n    default: substitute = function (from, to) { return 1; }; break; }\n\n    switch (typeof prices.transpose) {\n    case 'function': transpose = prices.transpose; break;\n    case 'number':\n        transpose = function (backward, forward) { return prices.transpose; };\n        break;\n    default: transpose = function (backward, forward) { return 1; }; break; }\n\n    function distance(down, across) {\n        // http://en.wikipedia.org/wiki/Damerau%E2%80%93Levenshtein_distance\n        var ds = [];\n        if ( down === across ) {\n            return 0;\n        } else {\n            down = down.split(''); down.unshift(null);\n            across = across.split(''); across.unshift(null);\n            down.forEach(function (d, i) {\n                if (!ds[i]) ds[i] = [];\n                across.forEach(function (a, j) {\n                    if (i === 0 && j === 0) ds[i][j] = 0;\n                    // Empty down (i == 0) -> across[1..j] by inserting\n                    else if (i === 0) ds[i][j] = ds[i][j-1] + insert(a);\n                    // Down -> empty across (j == 0) by deleting\n                    else if (j === 0) ds[i][j] = ds[i-1][j] + remove(d);\n                    else {\n                        // Find the least costly operation that turns\n                        // the prefix down[1..i] into the prefix\n                        // across[1..j] using already calculated costs\n                        // for getting to shorter matches.\n                        ds[i][j] = Math.min(\n                            // Cost of editing down[1..i-1] to\n                            // across[1..j] plus cost of deleting\n                            // down[i] to get to down[1..i-1].\n                            ds[i-1][j] + remove(d),\n                            // Cost of editing down[1..i] to\n                            // across[1..j-1] plus cost of inserting\n                            // across[j] to get to across[1..j].\n                            ds[i][j-1] + insert(a),\n                            // Cost of editing down[1..i-1] to\n                            // across[1..j-1] plus cost of\n                            // substituting down[i] (d) with across[j]\n                            // (a) to get to across[1..j].\n                            ds[i-1][j-1] + (d === a ? 0 : substitute(d, a))\n                        );\n                        // Can we match the last two letters of down\n                        // with across by transposing them? Cost of\n                        // getting from down[i-2] to across[j-2] plus\n                        // cost of moving down[i-1] forward and\n                        // down[i] backward to match across[j-1..j].\n                        if (damerau\n                            && i > 1 && j > 1\n                            && down[i-1] === a && d === across[j-1]) {\n                            ds[i][j] = Math.min(\n                                ds[i][j],\n                                ds[i-2][j-2] + (d === a ? 0 : transpose(d, down[i-1]))\n                            );\n                        };\n                    };\n                });\n            });\n            return ds[down.length-1][across.length-1];\n        };\n    };\n    return distance;\n};\n\nmodule.exports = DamerauLevenshtein;\n","import StringComparer from './helpers/string-comparers/string-comparer';\n\n/**\n * The translation currently in use\n *\n * @type {Object}\n */\nlet translation = null;\n\n/**\n * @typedef CommandsHash\n * @type {Object}\n * @property {string} command The command recognized\n * @property {string} [translationsPath=''] The path to the translations folder\n * @property {Object} [recognizer] The settings for the speech recognition functionality\n */\n\n/**\n * Extracts the heading level contained in the string provided.\n * If a perfect match is not found, the Damerau-Levenshtein algorithm\n * is used to find the closest match.\n *\n * @param {StringComparer} StringComparer The comparer to use for comparing strings\n * @param {string} recognizedText The string to analyze\n *\n * @return {Object}\n */\nfunction extractHeaderLevel(StringComparer, recognizedText) {\n   const headingLevels = translation.commands.READ_LEVEL_HEADERS.levels;\n   let data = {};\n\n   for(let i = 0; i < headingLevels.length; i++) {\n      let regexp = new RegExp(`(^|\\\\b)(${i + 1}|h${i + 1}|${headingLevels[i]})(\\\\b|$)`, 'i');\n\n      if (regexp.test(recognizedText)) {\n         data.level = i + 1;\n         break;\n      }\n   }\n\n   // If the header level has not been found yet,\n   // let's try a more heuristic strategy\n   if (!data.level) {\n      let closerMatchIndex = StringComparer.findCloserMatch(headingLevels, recognizedText).index;\n\n      data.level = closerMatchIndex === -1 ? -1 : closerMatchIndex + 1;\n   }\n\n   return data;\n}\n\n/**\n * Searches an element type, such as <code>main</code> or <code>footer</code>,\n * in the text provided. If none is found, <code>null</code> is returned\n *\n * @param {string} recognizedText The string to analyze\n *\n * @return {HTMLElement|null}\n */\nfunction findElementInText(recognizedText) {\n   let elements = translation.elements;\n   let foundElement = null;\n\n   for(let key in elements) {\n      let variations = elements[key].variations.join('|');\n      let regexp = new RegExp(`(^|\\\\b)(${variations})(\\\\b|$)`, 'i');\n\n      if (regexp.test(recognizedText)) {\n         foundElement = document.querySelector(elements[key].selector);\n         break;\n      }\n   }\n\n   return foundElement;\n}\n/**\n * Searches an element type, such as <code>main</code> or <code>footer</code>,\n * in the text provided. If none is found, the closest match is re is returned\n *\n * @param {StringComparer} StringComparer The comparer to use for comparing strings\n * @param {string} recognizedText The string to analyze\n *\n * @return {Object}\n */\nfunction extractElementFromText(StringComparer, recognizedText) {\n   let foundElement = findElementInText(recognizedText);\n\n   if (foundElement) {\n      return {\n         element: foundElement\n      };\n   }\n\n   // Collects the closer match for each element.\n   let closerMatches = [];\n   let elements = translation.elements;\n\n   // If the element has not been found yet,\n   // let's try a more heuristic strategy\n   for(let key in elements) {\n      let variations = elements[key].variations;\n      let closerMatchIndex = StringComparer.findCloserMatch(variations, recognizedText);\n\n      if (closerMatchIndex !== -1) {\n         closerMatches.push(variations[closerMatchIndex]);\n      }\n   }\n\n   // Find the closest match among the closest match\n   let closestMatch = StringComparer.findCloserMatch(closerMatches, recognizedText);\n\n   return {\n      element: closestMatch.index >= 0 ? closerMatches[closestMatch.index] : null\n   };\n}\n\n/**\n * Extracts relevant data from a string, based on the recognized command\n *\n * @param {StringComparer} StringComparer The comparer to use for comparing strings\n * @param {string} command The recognized command\n * @param {string} recognizedText The string from which the data are extracted\n *\n * @return {Object}\n */\nfunction extractData(StringComparer, command, recognizedText) {\n   let data = {};\n\n   if (command === 'READ_LEVEL_HEADERS') {\n      console.debug('Extracting header level from text');\n      data = extractHeaderLevel(StringComparer, recognizedText);\n   } else if (command === 'READ_LINKS_IN_ELEMENT') {\n      console.debug('Extracting element from text');\n      data = extractElementFromText(StringComparer, recognizedText);\n   }\n\n   return data;\n}\n\n/**\n * The class responsible for the commands\n *\n * @class\n */\nexport\n   default class Commands {\n   /**\n    * Creates an instance of Commands\n    *\n    * @constructor\n    *\n    * @param {StringComparer} Comparer The class representing the strategy to adopt to compare strings\n    */\n   constructor(Comparer) {\n      if (!(Comparer.prototype instanceof StringComparer)) {\n         throw new TypeError(`${arguments[0]} is not an instance of StringComparer`);\n      }\n\n      Object.defineProperty(this, 'StringComparer', {\n         enumerable: false,\n         configurable: false,\n         get: function() {\n            return Comparer;\n         }\n      });\n   }\n\n   /**\n    * Detects the action to perform and extracts any relevant data\n    * based on the string provided\n    *\n    * @param {string} recognizedText The string to analyze\n    * @param {Object} currentTranslation The object containing the translation of the application\n    *\n    * @return {CommandsHash}\n    */\n   recognizeCommand(recognizedText, currentTranslation) {\n      let minDistance = Number.POSITIVE_INFINITY;\n      let commands = currentTranslation.commands;\n      let foundCommand;\n\n      translation = currentTranslation;\n      recognizedText = recognizedText.toLocaleLowerCase();\n\n      console.debug('Command recognition started');\n\n      for(let command in commands) {\n         let closerMatch = this.StringComparer.findCloserMatch(\n            [commands[command].text].concat(commands[command].variations),\n            recognizedText\n         );\n\n         if (closerMatch.distance < minDistance) {\n            foundCommand = Object.assign({\n               command\n            }, extractData(this.StringComparer, command, recognizedText));\n\n            if (closerMatch.distance === 0) {\n               break;\n            } else {\n               minDistance = closerMatch.distance;\n            }\n         }\n      }\n\n      console.debug(`Command recognition ended. Found command \"${commands[foundCommand.command].text}\"`);\n      console.debug('Extrapolated data:', foundCommand);\n\n      return foundCommand;\n   }\n}","/**\n * Returns the title of the current document\n *\n * @return {string}\n */\nfunction getTitle() {\n   return document.title;\n}\n\nexport {\n   getTitle\n};","import {getTitle} from './document';\nimport {getHeaders} from './headers';\nimport {getLinks} from './links';\nimport {getMain} from './main';\n\n/**\n * Highlights an element in the current document by wrapping it\n * with a <code>mark</code> element\n *\n * @param {HTMLElement} element The element to highlight\n */\nfunction highlightElement(element) {\n   if (!(element instanceof HTMLElement)) {\n      return;\n   }\n\n   element.innerHTML = `<mark>${element.innerHTML}</mark>`;\n}\n\n/**\n * Unhighlights an element in the current document by removing\n * the <code>mark</code> element wrapping it\n *\n * @param {HTMLElement} element The element to unhighlight\n */\nfunction unhighlightElement(element) {\n   if (!(element instanceof HTMLElement)) {\n      return;\n   }\n\n   element.innerHTML = element.innerHTML\n      .replace(/^<mark>/, '')\n      .replace(/<\\/mark>$/, '');\n}\n\nexport\n default {\n   getHeaders,\n   getLinks,\n   getMain,\n   getTitle,\n   highlightElement,\n   unhighlightElement\n};","/**\n * Returns the level of a header (1 for an <code>h1</code>, 2 for an <code>h2</code>,\n * and so on). If the element is not an header or it is not defined, zero is returned\n *\n * @param {HTMLElement} element\n *\n * @return {number}\n */\nfunction getHeaderLevel(element) {\n   if (!element || !element.nodeName || element.nodeName.toLowerCase().indexOf('h') !== 0) {\n      return 0;\n   }\n\n   return parseInt(element.nodeName.charAt(1), 10);\n}\n\n/**\n * Returns all the headers of a page in a tree structure. Each element\n * possesses two properties: element and subheadings. The former\n * is an <code>HTMLElement</code> referencing the header, while the latter is an array\n * containing all the subheadings of the header.\n *\n * @param {HTMLElement[]} headers The headers to use to create the tree\n *\n * @return {Object[]}\n */\nfunction createHeadingsStructure(headers) {\n   let tree = [];\n\n   (function recurse(headers, index, tree) {\n      if (index.index === headers.length) {\n         return tree;\n      }\n\n      let headerLevel = getHeaderLevel(headers[index.index]);\n      let header = {\n         element: headers[index.index],\n         subheadings: []\n      };\n\n      if (tree.length === 0 || headerLevel === getHeaderLevel(tree[tree.length - 1].element)) {\n         tree.push(header);\n         index.index++;\n\n         return recurse(headers, index, tree);\n      }\n\n      if (headerLevel > getHeaderLevel(tree[tree.length - 1].element)) {\n         tree[tree.length - 1].subheadings = recurse(headers, index, []);\n      }\n\n      headerLevel = getHeaderLevel(headers[index.index]);\n\n      if (headerLevel === getHeaderLevel(tree[tree.length - 1].element)) {\n         return recurse(headers, index, tree);\n      } else {\n         return tree;\n      }\n   })(headers, {\n      index: 0\n   }, tree);\n\n   return tree;\n}\n\n/**\n * Returns all the headers of a page, optionally filtered\n *\n * @param {Object} [filters={}] An object used to filters the headers to return\n * @param {number} [filters.level=-1] An integer that specifies the level to retrieve.\n * If set  to -1 retrieves all the headers\n * @param {string} [filters.text=''] A string that must be contained in the header's text\n *\n * @return {HTMLElement[]}\n */\nfunction getHeaders(filters = {}) {\n   let selector;\n\n   filters = Object.assign(\n      {\n         level: -1,\n         text: ''\n      },\n      filters\n   );\n\n   if (filters.level === -1) {\n      selector = 'h1, h2, h3, h4, h5, h6';\n   } else {\n      selector = `h${filters.level}`;\n   }\n\n   let filterTextRegExp = new RegExp(`(^|\\\\b)${filters.text}(\\\\b|$)`, 'i');\n   let headers = Array\n      .from(document.querySelectorAll(selector))\n      .filter(header => header.textContent.search(filterTextRegExp) >= 0);\n\n   return headers;\n}\n\nexport {\n   createHeadingsStructure,\n   getHeaders\n};","/**\n * Determines if a link would be read or not by a classic screen reader\n *\n * @param {HTMLElement} element The element to test\n *\n * @return {boolean}\n */\nfunction isScreenReaderVisible(element) {\n   return window.getComputedStyle(element).display !== 'none' &&\n          element.getAttribute('aria-hidden') !== 'true';\n}\n\n/**\n * Returns all the links of a page, optionally filtered\n *\n * @param {Object} [filters={}] An object used to filters the links\n * @param {(HTMLElement|HTMLDocument)} [filters.ancestor=document] The ancestor of the links to retrieve\n *\n * @return {HTMLElement[]}\n */\nfunction getLinks(filters = {}) {\n   filters = Object.assign(\n      {\n         ancestor: document\n      },\n      filters\n   );\n\n   let links = filters.ancestor.querySelectorAll('a');\n\n   return Array\n      .from(links)\n      .filter(element => isScreenReaderVisible(element));\n}\n\nexport {\n   getLinks\n};","/**\n * Returns the main element of the page.\n * If the element is not found, an heuristic is employed to find a possible\n * main element. If the heuristic approach fails, <code>null</code> is returned\n *\n * @return {HTMLElement|null}\n */\nfunction getMain() {\n   let main = document.querySelector('main') ||\n              document.querySelector('[role=\"main\"]');\n\n   // If a main has not been found, let's use an heuristic to find\n   // a possible main content that has not been marked as such.\n   if (!main) {\n      let possibleMain = document.querySelectorAll('#main-content, .main-content, #main, .main');\n\n      // If only one element is found, it's highly possible\n      // that it's the true main content of the page.\n      if (possibleMain.length === 1) {\n         main = possibleMain[0];\n      }\n   }\n\n   return main;\n}\n\nexport {\n   getMain\n};","/**\n * The class representing an event emitter\n *\n * @class\n */\nexport\n   default class EventEmitter {\n   /**\n    * Returns the namespace of the events\n    *\n    * @return {string}\n    */\n   static get namespace() {\n      return 'webreader';\n   }\n\n   /**\n    * Namespaces an event\n    *\n    * @param {string} eventName The event name\n    *\n    * @return {string}\n    */\n   static namespaceEvent(eventName) {\n      return `${EventEmitter.namespace}.${eventName}`;\n   }\n\n   /**\n    * Fires an event\n    *\n    * @param {string} eventName The name of the event\n    * @param {HTMLElement|Document} element The element on which the event is dispatched\n    * @param {Object} [properties={}] A set of key-values to assign to the event\n    */\n   static fireEvent(eventName, element, properties = {}) {\n      let customEvent = document.createEvent('Event');\n\n      customEvent.initEvent(eventName, true, true);\n\n      Object\n         .getOwnPropertyNames(properties)\n         .forEach(property => customEvent[property] = properties[property]);\n\n      element.dispatchEvent(customEvent);\n   }\n}","import DamerauLevenshtein from 'damerau-levenshtein';\nimport StringComparer from './string-comparer';\n\n/**\n * The class representing a comparer using the Damerau-Levenshtein algorithm\n *\n * @class\n */\nexport\n   default class DamerauLevenshteinComparer extends StringComparer {\n   /**\n    * Finds the closest match of a string using the Damerau-Levenshtein algorithm\n    *\n    * @param {(string|string[])} string The string or the array of strings to test\n    * @param {string} target The string to test against\n    *\n    * @return {Object}\n    */\n   static findCloserMatch(string, target) {\n      if (!Array.isArray(string)) {\n         string = [string];\n      }\n\n      let damerauLevenshtein = DamerauLevenshtein(); // jshint ignore:line\n      let minDistance = Number.POSITIVE_INFINITY;\n      let index = -1;\n\n      for(let i = 0; i < string.length; i++) {\n         let distance = damerauLevenshtein(string[i], target);\n\n         console.debug(`The distance between \"${string[i]}\" and \"${target}\" is ${distance}`);\n\n         if (distance === 0 || distance < minDistance) {\n            minDistance = distance;\n            index = i;\n\n            // If a perfect match is found, exit immediately\n            if (distance === 0) {\n               break;\n            }\n         }\n      }\n\n      return {\n         index: index,\n         distance: minDistance\n      };\n   }\n}","/**\n * An interface representing a string comparer\n *\n * @interface\n */\nexport\n   default class StringComparer {\n      /**\n       * Finds the closest match of a string\n       *\n       * @abstract\n       *\n       * @param {(string|string[])} string The string or the array of strings to test\n       * @param {string} target The string to test against\n       *\n       * @return {Object}\n       */\n      /* jshint ignore:start */\n      static findCloserMatch(string, target) {\n         throw new Error(`The ${arguments.callee.name} function must be overridden`);\n      }\n      /* jshint ignore:end */\n   }\n","/**\n * The class representing a timer\n *\n * @class\n */\nexport\n   default class Timer {\n   /**\n    * Waits for the amount of milliseconds specified\n    *\n    * @param {number} milliseconds The amount of milliseconds to wait\n    *\n    * @return {Promise}\n    */\n   static wait(milliseconds) {\n      return new Promise(resolve => window.setTimeout(resolve, milliseconds));\n   }\n}","import Commands from './commands';\nimport Dom from './dom/dom';\nimport Recognizer from './reader/recognizer';\nimport Router from './router';\nimport Speaker from './reader/speaker';\nimport EventEmitter from './helpers/event-emitter';\nimport DamerauLevenshteinComparer from './helpers/string-comparers/damerau-levenshtein-comparer';\nimport Timer from './helpers/timer';\nimport WebReaderError from './webreader-error';\nimport defaultTranslation from '../lang/en-GB.json';\n\nconst defaultLanguage = 'en-GB';\n\n/**\n * @typedef SettingsHash\n * @type {Object}\n * @property {number} [delay=300] The delay between each spoken text\n * @property {string} [translationsPath=''] The path to the translations folder\n * @property {SpeechRecognitionHash} [recognizer] The settings for the speech recognition functionality\n * @property {SpeechSynthesisUtteranceHash} [speaker] The settings for the speech synthesis functionality\n * functionality\n */\n\n/**\n * The default values for the settings available\n *\n * @type {SettingsHash}\n */\nconst defaults = {\n   delay: 300,\n   translationsPath: '',\n   recognizer: {\n      lang: defaultLanguage\n   },\n   speaker: {\n      lang: defaultLanguage,\n      voice: 'Google UK English Female'\n   }\n};\n\nconst defaultState = {\n   isInteracting: false,\n   elements: null,\n   currentIndex: -1\n};\n\nlet eventListenersMap = new WeakMap();\nlet statusMap = new WeakMap();\nlet translations = new Map([[defaultLanguage, defaultTranslation]]);\n\n/**\n * Downloads a translation for the commands available\n *\n * @param {string} translationsPath The path to the translations folder\n * @param {string} language The language to download\n *\n * @return {Promise}\n */\nfunction downloadTranslation(translationsPath, language) {\n   return window\n      .fetch(`${translationsPath}/${language}.json`)\n      .then(response => response.json())\n      .then(response => {\n         translations.set(language, response);\n\n         return response;\n      });\n}\n\n/**\n * Performs certain actions based on the shortcuts pressed by the user\n *\n * @param {WebReader} webReader An instance of WebReader\n * @param {Event} event An event\n */\nfunction listenShortcuts(webReader, event) {\n   if (\n      event.ctrlKey === true &&\n      (event.code && event.code === 'Space' || event.which === 32)\n   ) {\n      if (webReader.isInteracting()) {\n         let state = statusMap.get(webReader);\n\n         if (state.elements) {\n            Dom.unhighlightElement(state.elements[state.currentIndex]);\n         }\n\n         webReader.stopCommand();\n      } else {\n         webReader.receiveCommand();\n      }\n   }\n}\n\n/**\n * The class representing the library\n *\n * @class\n */\nexport\n   default class WebReader {\n   /**\n    * Creates an instance of WebReader\n    *\n    * @constructor\n    *\n    * @param {SettingsHash} [options={}] The options to customize WebReader\n    */\n   constructor(options = {}) {\n      /**\n       * @type {Object}\n       */\n      this.settings = Object.assign({}, defaults, options);\n      /**\n       *\n       * @type {Recognizer}\n       */\n      this.recognizer = new Recognizer(this.settings.recognizer);\n      /**\n       *\n       * @type {Speaker}\n       */\n      this.speaker = new Speaker(this.settings.speaker);\n\n      statusMap.set(this, Object.assign({}, defaultState));\n      eventListenersMap.set(this, new Map());\n\n      let language = this.settings.recognizer.lang;\n\n      if (language && !translations.has(language)) {\n         downloadTranslation(this.settings.translationsPath, language)\n            .then(\n               () => {\n                  let message = `Language \"${language}\" successfully loaded`;\n\n                  console.debug(message);\n\n                  EventEmitter.fireEvent(`${EventEmitter.namespace}.languagedownload`, document, {\n                     data: {\n                        lang: language\n                     }\n                  });\n\n                  return this.speaker.speak(message);\n               },\n               err => {\n                  console.debug(err.message);\n\n                  EventEmitter.fireEvent(`${EventEmitter.namespace}.languageerror`, document, {\n                     data: {\n                        lang: language\n                     }\n                  });\n\n                  return this.speaker.speak(`An error occurred: the language \"${language}\" was not loaded`);\n               }\n            );\n      }\n   }\n\n   /**\n    * Determines if WebReader is currently interacting with the user\n    *\n    * @return {boolean}\n    */\n   isInteracting() {\n      return statusMap.get(this).isInteracting;\n   }\n\n   /**\n    * Enables the keyboard shortcuts provided\n    *\n    * @return {WebReader}\n    */\n   enableShortcuts() {\n      let eventListeners = eventListenersMap.get(this);\n\n      eventListeners.set('keydown', listenShortcuts.bind(this, this));\n\n      document.documentElement.addEventListener('keydown', eventListeners.get('keydown'));\n\n      return this;\n   }\n\n   /**\n    * Disables the keyboard shortcuts provided\n    *\n    * @return {WebReader}\n    */\n   disableShortcuts() {\n      let eventListeners = eventListenersMap.get(this);\n\n      document.documentElement.removeEventListener('keydown', eventListeners.get('keydown'));\n      eventListeners.delete('keydown');\n\n      return this;\n   }\n\n   /**\n    * Starts the interaction with the user to receive a vocal command.\n    * If a supported command is recognized, the required action is executed.\n    *\n    * @return {Promise}\n    */\n   receiveCommand() {\n      statusMap.get(this).isInteracting = true;\n      console.debug('Interaction started');\n\n      EventEmitter.fireEvent(`${EventEmitter.namespace}.interactionstart`, document);\n\n      return this.speaker\n         .speak('Ready')\n         .then(() => this.recognizer.recognize())\n         .then(recognizedText => {\n            let commands = new Commands(DamerauLevenshteinComparer);\n            let translation = translations.get(this.settings.recognizer.lang);\n\n            return commands.recognizeCommand(recognizedText, translation);\n         })\n         .then(recognizedCommand => Router.route(this, recognizedCommand))\n         .catch(error => {\n            if (error instanceof WebReaderError) {\n               return this.speaker.speak(error.message);\n            }\n\n            if (error.error !== 'aborted' && error.error !== 'interrupted') {\n               console.debug('An error occurred', error);\n\n               statusMap.set(this, Object.assign({}, defaultState));\n\n               return this.speaker.speak('Sorry, I could not recognize the command');\n            }\n         })\n         .then(// Simulate an always() method\n            () => {},\n            () => {}\n         )\n         .then(() => {\n            statusMap.get(this).isInteracting = false;\n            console.debug('Interaction completed');\n\n            EventEmitter.fireEvent(`${EventEmitter.namespace}.interactionend`, document);\n         });\n   }\n\n   /**\n    * Stops the interaction\n    */\n   stopCommand() {\n      this.recognizer.abort();\n      this.speaker.cancel();\n      statusMap.get(this).isInteracting = false;\n      console.debug('Interaction stopped');\n   }\n\n   /**\n    * Reads all the headers of a page, optionally filtered\n    *\n    * @param {Object} [filters={}] The filters to apply\n    * @param {number} [filters.level=-1] The level of the headers to read\n    * (e.g. 1 means read all and only the H1 on the page).\n    * If -1 is provided, all the headers are read\n    *\n    * @return {Promise}\n    */\n   readHeaders(filters = {}) {\n      let headers = Dom.getHeaders(filters);\n      let level = filters && filters.level ? filters.level : -1;\n\n      statusMap.get(this).elements = headers;\n\n      return headers.reduce((promise, header, index) => {\n         promise = promise.then(() => {\n            statusMap.get(this).currentIndex = index;\n            Dom.highlightElement(header);\n\n            return this.speaker\n               .speak(header.textContent + (level !== -1 ? '' : ` ${header.nodeName}`))\n               .then(() => Dom.unhighlightElement(header))\n               .catch(error => {\n                  Dom.unhighlightElement(header);\n\n                  return Promise.reject(error);\n               });\n         });\n\n         if (this.settings.delay > 0) {\n            promise = promise.then(() => Timer.wait(this.settings.delay));\n         }\n\n         return promise;\n      }, Promise.resolve());\n   }\n\n   /**\n    * Reads again the last element processed\n    *\n    * @return {Promise}\n    */\n   readCurrentElement() {\n      let state = statusMap.get(this);\n\n      if (!state.elements) {\n         return Promise.reject(new WebReaderError('There is not a current element to read'));\n      }\n\n      let element = state.elements[state.currentIndex];\n\n      Dom.highlightElement(element);\n\n      return this.speaker\n         .speak(element.textContent)\n         .then(() => Dom.unhighlightElement(element))\n         .catch(error => {\n            Dom.unhighlightElement(element);\n\n            return Promise.reject(error);\n         });\n   }\n\n   /**\n    * Reads the previous element\n    *\n    * @return {Promise}\n    */\n   readPreviousElement() {\n      let state = statusMap.get(this);\n\n      if (state.currentIndex === 0) {\n         return Promise.reject(new WebReaderError('The current element is the first'));\n      }\n\n      state.currentIndex--;\n\n      return this.readCurrentElement();\n   }\n\n   /**\n    * Reads the next element\n    *\n    * @return {Promise}\n    */\n   readNextElement() {\n      let state = statusMap.get(this);\n\n      if (state.currentIndex === state.elements.length - 1) {\n         return Promise.reject(new WebReaderError('The current element is the last'));\n      }\n\n      state.currentIndex++;\n\n      return this.readCurrentElement();\n   }\n\n   /**\n    * Follows the last read link\n    *\n    * @throws {WebReaderError} the current element is not a link\n    */\n   goToLink() {\n      let state = statusMap.get(this);\n      let currentElement = state.elements ? state.elements[state.currentIndex] : null;\n\n      if (!currentElement || currentElement.nodeName !== 'A') {\n         throw new WebReaderError('There is not a current link to follow');\n      }\n\n      window.location.assign(currentElement.href);\n   }\n\n   /**\n    * Reads all the links of a page\n    *\n    * @param {Object} [filters={}] An object used to filters the links\n    *\n    * @return {Promise}\n    */\n   readLinks(filters) {\n      let links = Dom.getLinks(filters);\n\n      statusMap.get(this).elements = links;\n\n      return links.reduce((promise, link, index) => {\n         promise = promise.then(() => {\n            statusMap.get(this).currentIndex = index;\n\n            return this.readCurrentElement();\n         });\n\n         if (this.settings.delay > 0) {\n            promise = promise.then(() => Timer.wait(this.settings.delay));\n         }\n\n         return promise;\n      }, Promise.resolve());\n   }\n\n   /**\n    * Reads the main element of the page\n    *\n    * @return {Promise}\n    */\n   readMain() {\n      let main = Dom.getMain();\n      let state = statusMap.get(this);\n\n      state.elements = [main];\n      state.currentIndex = 0;\n\n      if (!main) {\n         return Promise.reject(new WebReaderError('The main content of this page cannot be found'));\n      }\n\n      return this.speaker.speak(main.textContent);\n   }\n\n   /**\n    * Searches the main content of the page. If the element is found, it is focused\n    *\n    * @throws {WebReaderError} main content is not found\n    */\n   searchMain() {\n      let main = Dom.getMain();\n\n      if (!main) {\n         throw new WebReaderError('The main content of this page has not been found');\n      }\n\n      let oldTabIndex = main.getAttribute('tabindex');\n\n      main.setAttribute('tabindex', -1);\n      main.addEventListener('blur', function removeTabIndex() {\n         main.removeEventListener('blur', removeTabIndex);\n\n         // Restore tabindex's old value, if any\n         if (oldTabIndex) {\n            main.setAttribute('tabindex', oldTabIndex);\n         } else {\n            main.removeAttribute('tabindex');\n         }\n      });\n      main.focus();\n   }\n\n   /**\n    * Reads the title of a page, if present or not empty\n    *\n    * @return {Promise}\n    */\n   readPageTitle() {\n      let title = Dom.getTitle();\n\n      if (title) {\n         return this.speaker.speak(`The title of the page is ${title}`);\n      } else {\n         return this.speaker.speak('This page does not have a title');\n      }\n   }\n\n   /**\n    * Reads a summary of the content of the page\n    *\n    * @return {Promise}\n    */\n   readPageSummary() {\n      let headers = Dom.getHeaders();\n      let links = Dom.getLinks();\n\n      return this.speaker.speak(`The page contains ${headers.length} headers and ${links.length} links`);\n   }\n\n   /**\n    * Goes to the previous page as specified by the browser's history\n    *\n    * @return {Promise}\n    */\n   goToPreviousPage() {\n      return new Promise((resolve, reject) => {\n         function onPopState() {\n            window.removeEventListener('popstate', onPopState);\n            resolve();\n         }\n\n         window.addEventListener('popstate', onPopState);\n         window.history.back();\n\n         // For privacy reasons a script doesn't have access to the list of pages\n         // visited by the user. So, there is no way to detect if the current page\n         // is already the first of the history. If that is the case, the\n         // \"popstate\" event won't be triggered and there is no way to know when\n         // to reject the promise (for example by checking that the current page has\n         // the same URL of the previous one).\n         //\n         // This hack allows to reject the promise if it hasn't been already resolved\n         // by the event listener for the \"popstate\" event.\n         setTimeout(() => {\n            reject(new WebReaderError('This is already the first page'));\n            window.removeEventListener('popstate', onPopState);\n         }, 10);\n      });\n   }\n\n   /**\n    * Goes to the next page as specified by the browser's history\n    *\n    * @return {Promise}\n    */\n   goToNextPage() {\n      return new Promise((resolve, reject) => {\n         function onPopState() {\n            window.removeEventListener('popstate', onPopState);\n            resolve();\n         }\n\n         window.addEventListener('popstate', onPopState);\n         window.history.forward();\n\n         // To know the rationale behind this hack, read the comment inside\n         // the \"goToPreviousPage()\" function.\n         setTimeout(() => {\n            reject(new WebReaderError('This is already the last page'));\n            window.removeEventListener('popstate', onPopState);\n         }, 10);\n      });\n   }\n\n   /**\n    * Goes to the homepage\n    */\n   goToHomepage() {\n      window.location.assign('/');\n   }\n}","import EventEmitter from '../helpers/event-emitter';\nimport WebReaderError from '../webreader-error';\n\n/**\n * @typedef SpeechRecognitionHash\n * @type {Object}\n * @property {Object[]} [grammars=[]] The collection of <code>SpeechGrammar</code> objects\n * which represent the grammars that are active for this recognition\n * @property {string} [lang=''] The language of the recognition for the request.\n * If unspecified it defaults to the language of the html document root element\n * @property {boolean} [continuous=false] Controls whether the interaction is stopped when the user\n * stops speaking or not\n * @property {boolean} [interimResults=false] Controls whether interim results are returned or not\n * @property {number} [maxAlternatives=1] The maximum number of <code>SpeechRecognitionAlternative</code>s per result\n * @property {string} [serviceURI=''] The location of the speech recognition service to use\n *\n * @see https://dvcs.w3.org/hg/speech-api/raw-file/tip/webspeechapi.html#speechreco-attributes\n */\n\n/**\n * Retrieves the object that allows to recognize the speech or\n * <code>null</code> if the feature is not supported\n *\n * @returns {SpeechRecognition|null}\n */\nfunction getRecognizer() {\n   return window.SpeechRecognition ||\n          window.webkitSpeechRecognition ||\n          null;\n}\n\n/**\n * Binds one or more events to a <code>SpeechRecognition</code> object\n *\n * @param {SpeechRecognition} recognizer A <code>SpeechRecognition</code> object\n * @param {Object} eventsHash An object of name-function pairs,\n * where name is the event to listen and function is the function to attach\n */\nfunction bindEvents(recognizer, eventsHash) {\n   for(let eventName in eventsHash) {\n      recognizer.addEventListener(eventName, eventsHash[eventName]);\n   }\n}\n\n/**\n * Unbinds one or more events to a <code>SpeechRecognition</code> object\n *\n * @param {SpeechRecognition} recognizer A <code>SpeechRecognition</code> object\n * @param {Object} eventsHash An object of name-function pairs,\n * where name is the event to listen and function is the function to attach\n */\nfunction unbindEvents(recognizer, eventsHash) {\n   for(let eventName in eventsHash) {\n      recognizer.removeEventListener(eventName, eventsHash[eventName]);\n   }\n}\n\n/**\n * The class exposing the reading features of a web page\n *\n * @class\n */\nexport\n default class Recognizer {\n   /**\n    * Creates a Recognizer instance\n    *\n    * @constructor\n    *\n    * @param {SpeechRecognitionHash} [options={}] The options to customize the settings of the recognizer\n    */\n   constructor(options={}) {\n      let Recognizer = getRecognizer();\n\n      if (!Recognizer) {\n         throw Error('API not supported');\n      }\n\n      /**\n       * The speech recognizer used\n       *\n       * @type {SpeechRecognition}\n       */\n      this.recognizer = new Recognizer();\n\n      for(let key in options) {\n         if (options.hasOwnProperty(key) && this.recognizer[key] !== undefined) {\n            this.recognizer[key] = options[key];\n         }\n      }\n   }\n\n   /**\n    * Detects if the recognition feature is supported\n    *\n    * @returns {boolean}\n    */\n   static isSupported() {\n      return !!getRecognizer();\n   }\n\n   /**\n    * Starts the recognition of the speech\n    *\n    * @returns {Promise}\n    */\n   recognize() {\n      return new Promise((resolve, reject) => {\n         let recognizer = this.recognizer;\n         let eventsHash = {\n            audiostart: () => {\n               EventEmitter.fireEvent(`${EventEmitter.namespace}.recognitionstart`, document);\n            },\n            result: event => {\n               for(let i = event.resultIndex; i < event.results.length; i++) {\n                  if (event.results[i].isFinal) {\n                     let bestGuess = event.results[i][0];\n\n                     console.debug('Recognition completed');\n                     console.debug(`Recognized \"${bestGuess.transcript}\" with a confidence of ${bestGuess.confidence}`);\n\n                     EventEmitter.fireEvent(`${EventEmitter.namespace}.recognitionresult`, document, {\n                        data: {\n                           result: bestGuess\n                        }\n                     });\n\n                     resolve(bestGuess.transcript);\n                  }\n               }\n            },\n            error: event => {\n               console.debug('Recognition error:', event.error);\n\n               EventEmitter.fireEvent(`${EventEmitter.namespace}.recognitionerror`, document, {\n                  error: event.error\n               });\n\n               reject(new WebReaderError('An error has occurred while recognizing your speech'));\n            },\n            noMatch: () => {\n               console.debug('Recognition ended because of nomatch');\n\n               EventEmitter.fireEvent(`${EventEmitter.namespace}.recognitionnomatch`, document);\n\n               reject(new WebReaderError('Sorry, I could not find a match'));\n            },\n            end: () => {\n               console.debug('Recognition ended');\n\n               EventEmitter.fireEvent(`${EventEmitter.namespace}.recognitionend`, document);\n\n               unbindEvents(recognizer, eventsHash);\n\n               // If the Promise isn't resolved or rejected at this point\n               // the demo is running on Chrome and Windows 8.1 (issue #428873).\n               reject(new WebReaderError('Sorry, I could not recognize your speech'));\n            }\n         };\n\n         bindEvents(this.recognizer, eventsHash);\n\n         console.debug('Recognition started');\n         this.recognizer.start();\n      });\n   }\n\n   /**\n    * Stops listening and recognizing the speech of the user\n    */\n   abort() {\n      this.recognizer.abort();\n   }\n}","import EventEmitter from '../helpers/event-emitter';\nimport WebReaderError from '../webreader-error';\n\n/**\n * This constant is needed because Chrome doesn't fire an error event\n * if the <code>cancel()</code> method is called.\n *\n * @type {Symbol}\n */\nconst isCancelledSymbol = Symbol('isCancelled');\n\n/**\n * @typedef SpeechSynthesisUtteranceHash\n * @type {Object}\n * @property {string} text The text to be synthesized and spoken\n * @property {string} [lang=''] The language of the speech synthesis for the utterance.\n * If unspecified it defaults to the language of the html document root element\n * @property {string} [voice=''] The voice to use\n * @property {number} [volume=1.0] The speaking volume\n * @property {number} [rate=1.0] The speaking rate\n * @property {number} [pitch=1.0] The speaking pitch\n *\n * @see https://dvcs.w3.org/hg/speech-api/raw-file/tip/webspeechapi.html#utterance-attributes\n */\n\n/**\n * Retrieves the object that allows to speech the text or\n * <code>null</code> if the feature is not supported\n *\n * @returns {speechSynthesis|null}\n */\nfunction getSpeaker() {\n   return window.speechSynthesis ||\n          null;\n}\n\n/**\n * Searches a voice among those provided\n *\n * @param {SpeechSynthesisUtterance[]} voices The voices available\n * @param {string} target The voice to search\n *\n * @return {SpeechSynthesisUtterance|undefined}\n */\nfunction searchVoice(voices, target) {\n   return voices\n      .filter(voice => voice.voiceURI === target)\n      .pop();\n}\n\n/**\n * Sets the settings for a <code>SpeechSynthesisUtterance</code> object\n *\n * @param {SpeechSynthesisUtterance} utterance The object whose settings will be set\n * @param {SpeechSynthesisUtteranceHash} settings\n * @param {SpeechSynthesisUtterance[]} voices The voices available\n */\nfunction setUtteranceSettings(utterance, settings, voices) {\n   for(let key in settings) {\n      if (!settings.hasOwnProperty(key) || utterance[key] === undefined) {\n         continue;\n      }\n\n      if (key !== 'voice') {\n         utterance[key] = settings[key];\n         continue;\n      }\n\n      let voice = searchVoice(voices, settings[key]);\n\n      if (voice) {\n         utterance[key] = voice;\n      } else {\n         console.debug('The voice selected is not available. Falling back to one available');\n         utterance[key] = voices[0];\n      }\n   }\n}\n\n/**\n * The class exposing the speaking features of a web page\n *\n * @class\n */\nexport\n default class Speaker {\n   /**\n    * Creates a Speaker instance\n    *\n    * @constructor\n    *\n    * @param {SpeechSynthesisUtteranceHash} [options={}] The options to customize the voice prompting the texts\n    */\n   constructor(options = {}) {\n      /**\n       *\n       * @type {speechSynthesis|null}\n       */\n      this.speaker = getSpeaker();\n      /**\n       *\n       * @type {SpeechSynthesisUtteranceHash}\n       */\n      this.settings = options;\n      /**\n       *\n       * @type {boolean}\n       */\n      this[isCancelledSymbol] = false;\n\n      if (!this.speaker) {\n         throw Error('API not supported');\n      }\n   }\n\n   /**\n    * Detects if the speech feature is supported\n    *\n    * @returns {boolean}\n    */\n   static isSupported() {\n      return !!getSpeaker();\n   }\n\n   /**\n    * Returns the list of voices available\n    *\n    * @return {Promise}\n    */\n   getVoices() {\n      return new Promise(resolve => {\n         let voices = this.speaker.getVoices();\n\n         if (voices.length > 1) {\n            return resolve(voices);\n         } else {\n            let onVoicesChanged = function() {\n               resolve(this.speaker.getVoices());\n\n               getSpeaker().removeEventListener('voiceschanged', onVoicesChanged);\n            }.bind(this);\n\n            getSpeaker().addEventListener('voiceschanged', onVoicesChanged);\n         }\n      });\n   }\n\n   /**\n    * Prompts a text\n    *\n    * @param {string} text The text to prompt\n    *\n    * @returns {Promise}\n    */\n   speak(text) {\n      return this\n         .getVoices()\n         .then(voices => {\n            return new Promise((resolve, reject) => {\n               let utterance = new window.SpeechSynthesisUtterance(text);\n               let eventData = Object.assign({\n                  text\n               }, this.settings);\n\n               setUtteranceSettings(utterance, this.settings, voices);\n\n               utterance.addEventListener('start', () => {\n                  console.debug(`Synthesizing the text: ${text}`);\n\n                  EventEmitter.fireEvent(`${EventEmitter.namespace}.synthesisstart`, document, {\n                     data: eventData\n                  });\n               });\n\n               utterance.addEventListener('end', () => {\n                  console.debug('Synthesis completed');\n\n                  EventEmitter.fireEvent(`${EventEmitter.namespace}.synthesisend`, document, {\n                     data: eventData\n                  });\n\n                  if (this[isCancelledSymbol]) {\n                     this[isCancelledSymbol] = false;\n\n                     return reject({\n                        error: 'interrupted'\n                     });\n                  }\n\n                  resolve();\n               });\n\n               utterance.addEventListener('error', event => {\n                  console.debug('Synthesis error: ', event.error);\n\n                  EventEmitter.fireEvent(`${EventEmitter.namespace}.synthesiserror`, document, {\n                     data: eventData\n                  });\n\n                  reject(new WebReaderError('An error has occurred while speaking'));\n               });\n\n               this.speaker.speak(utterance);\n            });\n         });\n   }\n\n   /**\n    * Stops the prompt of the utterance\n    */\n   cancel() {\n      this.speaker.cancel();\n      this[isCancelledSymbol] = true;\n   }\n}","import WebReaderError from './webreader-error';\n\n/**\n * The class responsible of the routing of the commands\n *\n * @class\n */\nexport\n default class Router {\n   /**\n    * Performs an action based on the command recognized\n    *\n    * @param {WebReader} webReader An instance of WebReader\n    * @param {CommandsHash} recognizedCommand The command recognized\n    *\n    * @return {Promise}\n    */\n   static route(webReader, recognizedCommand) {\n      /* jshint -W074 */\n      if (recognizedCommand.command === 'READ_ALL_HEADERS') {\n         return webReader.readHeaders();\n      } else if (recognizedCommand.command === 'READ_ALL_LINKS') {\n         return webReader.readLinks();\n      } else if (recognizedCommand.command === 'READ_LEVEL_HEADERS') {\n         return webReader.readHeaders({\n            level: recognizedCommand.level\n         });\n      } else if (recognizedCommand.command === 'READ_MAIN') {\n         return webReader.readMain();\n      } else if (recognizedCommand.command === 'SEARCH_MAIN') {\n         return new Promise((resolve, reject) => {\n            try {\n               resolve(webReader.searchMain());\n            } catch(ex) {\n               reject(ex);\n            }\n         });\n      } else if (recognizedCommand.command === 'READ_AGAIN') {\n         return webReader.readCurrentElement();\n      } else if (recognizedCommand.command === 'READ_PREVIOUS') {\n         return webReader.readPreviousElement();\n      } else if (recognizedCommand.command === 'READ_NEXT') {\n         return webReader.readNextElement();\n      } else if (recognizedCommand.command === 'READ_PAGE_TITLE') {\n         return webReader.readPageTitle();\n      } else if (recognizedCommand.command === 'READ_LINKS_IN_ELEMENT') {\n         return webReader.readLinks({\n            ancestor: recognizedCommand.element\n         });\n      } else if (recognizedCommand.command === 'GO_TO_PREVIOUS_PAGE') {\n         return webReader.goToPreviousPage();\n      } else if (recognizedCommand.command === 'GO_TO_NEXT_PAGE') {\n         return webReader.goToNextPage();\n      } else if (recognizedCommand.command === 'READ_PAGE_SUMMARY') {\n         return webReader.readPageSummary();\n      } else if (recognizedCommand.command === 'GO_TO_HOMEPAGE') {\n         return Promise.resolve(webReader.goToHomepage());\n      } else if (recognizedCommand.command === 'GO_TO_LINK') {\n         return new Promise((resolve, reject) => {\n            try {\n               resolve(webReader.goToLink());\n            } catch(ex) {\n               reject(ex);\n            }\n         });\n      } else {\n         return Promise.reject(new WebReaderError('The command is not supported'));\n      }\n   }\n}","// @TODO Extends Error. At the moment, Babel doesn't support subclassing native types\n\n/**\n * The class representing the errors thrown by WebReader\n *\n * @class\n */\nexport\n default class WebReaderError {\n   /**\n    * Creates an instance of WebReaderError\n    *\n    * @constructor\n    *\n    * @param {string} message The message of the error\n    */\n   constructor(message) {\n      /**\n       * The name of error\n       *\n       * @type {string} WebReaderError\n       */\n      this.name = this.constructor.name;\n      /**\n       * The message describing the error\n       *\n       * @type {string}\n       */\n      this.message = message;\n   }\n}"]}